///////////////////////////////////////////////////////////////////////////
/// COMPILE_MAIN=ZIPsFS                                                 ///
/// In memory cache                                                     ///
/// Caching file data in main memory                                    ///
/// Usually applies to compressed ZIP entries and                       ///
/// autogenerated content and special files                             ///
///////////////////////////////////////////////////////////////////////////
#include "cg_crc32.c"
////////////////////////////////////
/// Parameters from command line ///
////////////////////////////////////
//if (is_preloadfileram(d,r))
static bool preloadfileram_set_maxbytes(const char *s){
  if ((_preloadfileram_bytes_limit=cg_atol_kmgt(s))<(1<<22)){
    log_error("Option -l: _preloadfileram_bytes_limit is too small %s\n",s);
    return false;
  }
  return true;
}
static bool preloadfileram_set_policy(const char *a){
  bool ok=false;
  const char *s;
  for(int i=0;!ok && (s=rm_pfx_us(WHEN_PRELOADFILERAM_S[i]));i++){
    if ((ok=!strcasecmp(s,a))) _preloadfileram_policy=i;
  }
  if (!ok){ log_error("Wrong option -c %s\n",a); ZIPsFS_usage(); }
  return ok;
}
///////////////////////////////
/// Decide for cache in RAM ///
///////////////////////////////
#define ramUsageForFilecontent()  (atomic_load(_countersB1+COUNT_TXTBUF_SEGMENT_MMAP)-atomic_load(_countersB2+COUNT_TXTBUF_SEGMENT_MMAP)+atomic_load(_countersB1+COUNT_TXTBUF_SEGMENT_MALLOC)-atomic_load(_countersB2+COUNT_TXTBUF_SEGMENT_MALLOC))

/* File info for virtual-path plus root-path Needed  when loading analysis.tdf, also wait for sufficient RAM  for analysis.tdf_bin */
static bool statForVirtualpathAndRootpath(struct stat *st, const char *vp, const char *rootpath){
  struct rootdata *r=NULL;
  foreach_root(r2) if (r2->rootpath==rootpath) r=r2;
  if (!r) return false;
  NEW_ZIPPATH(vp);
  //log_entered_function("%s r: %p",vp,r);
  const bool ok=find_realpath_for_root(zpath,r);
  *st=ok?zpath->stat_vp: empty_stat;
  //log_exited_function("%s found: %d  size: %ld ",vp,ok,st->st_size);
  return ok;
}

static bool preloadfileram_advise(const struct zippath *zpath, const int additional_flags,const bool wait_for_free_mem){
  cg_thread_assert_not_locked(mutex_fhandle);
  if (_preloadfileram_policy==PRELOADFILERAM_NEVER) return false;
  const off_t need_bytes=config_advise_preload_file_ram(additional_flags|
                                                    (ZPF(ZP_IS_COMPRESSED)?ADVISE_CACHE_IS_CMPRESSED:0)|
                                                    (ZPF(ZP_ZIP)?ADVISE_CACHE_IS_ZIPENTRY:0)|
                                                    ((_preloadfileram_policy==PRELOADFILERAM_COMPRESSED&&ZPF(ZP_IS_COMPRESSED) || ZPF(ZP_ZIP)&&_preloadfileram_policy==PRELOADFILERAM_ALWAYS)?ADVISE_CACHE_BY_POLICY:0),
                                                    VP(),VP_L(),RP(),RP_L(),zpath->root->rootpath,zpath->stat_vp.st_size);
  if (need_bytes<0) return false;
  if (need_bytes>_preloadfileram_bytes_limit){
    warning(WARN_PRELOADFILERAM|WARN_FLAG_ONCE,VP(),"%'lld>%'lld. Consider set byte limit for RAM cache with  "ANSI_FG_BLUE"-l <gigabytes>G"ANSI_RESET,(LLD)need_bytes,(LLD)_preloadfileram_bytes_limit);
    return false;
  }
  if (wait_for_free_mem){
    for(off_t u; (u=ramUsageForFilecontent()+need_bytes)>_preloadfileram_bytes_limit;){
      log_verbose("Pause while high RAM usage:  %s usage+need >= max  (%'lld+%'lld >= %'lld \n",VP(),(LLD)u,(LLD)need_bytes,(LLD)_preloadfileram_bytes_limit);
      usleep((1<<20));
    }
  }
  return true;
}

#define fhandle_preloadfileram_advise(d) preloadfileram_advise(&d->zpath,(d->flags&FHANDLE_FLAG_SEEK_BW_FAIL)?ADVISE_CACHE_IS_SEEK_BW:0,true)  /* Called from xmp_read() */
#define zpath_preloadfileram_advise(zpath) preloadfileram_advise(zpath,0,false) /* Called from xmp_open() */

//////////////
/// Status ///
//////////////
static enum enum_preloadfileram_status preloadfileram_get_status(const struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  return d && d->preloadfileram?d->preloadfileram->preloadfileram_status:preloadfileram_status_nil;
}
static void preloadfileram_set_status(struct fHandle *d,enum enum_preloadfileram_status status){
  ASSERT_LOCKED_FHANDLE();
  if (d && d->preloadfileram) d->preloadfileram->preloadfileram_status=status;
}
//////////////////////////////////
/// Constructor and Destructor ///
//////////////////////////////////
static struct preloadfileram *preloadfileram_new(struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  if (!d->preloadfileram){
    static int id;
    (d->preloadfileram=cg_calloc(COUNT_PRELOADFILERAM_MALLOC,1,sizeof(struct preloadfileram)))->id=++id;
    d->preloadfileram->preloadfileram_l=d->zpath.stat_vp.st_size;
    d->preloadfileram->m_zpath=d->zpath;

    foreach_fhandle(ie,e){
      if (fhandle_virtualpath_equals(d,e)){
        ASSERT(d->flags&FHANDLE_FLAG_SPECIAL_FILE || !e->preloadfileram);
        e->preloadfileram=d->preloadfileram;
      }
    }
  }
  return d->preloadfileram;
}
static bool preloadfileram_try_destroy(struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  struct preloadfileram *m=d->preloadfileram;
  if (m){
    if (is_preloadfileram_shared_with_other(d)) return false;
    log_entered_function("'%s'", D_VP(d));
    textbuffer_destroy(m->txtbuf);
    FREE_NULL_MALLOC_ID(m->txtbuf);
    cg_free_null(COUNT_PRELOADFILERAM_MALLOC,d->preloadfileram);
    foreach_fhandle_also_emty(id,e) if (e->preloadfileram==m) e->preloadfileram=NULL;
  }
  return true;
}
//////////////////////////////////////////////////////////////////////////////////////////
/// Instances of struct preloadfileram are shared by multiple instances of struct fHandle,   ///
/// when a file is open multiple times in the client app.                              ///
//////////////////////////////////////////////////////////////////////////////////////////
static void preloadfileram_infer_from_other_handle(struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  foreach_fhandle(ie,e){
    if (e->preloadfileram && fhandle_virtualpath_equals(d,e)){
      d->preloadfileram=e->preloadfileram;
      break;
    }
  }
}
static bool is_preloadfileram_shared_with_other(const struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  if (d->preloadfileram){
    foreach_fhandle(id,e){
      if (e!=d && e->preloadfileram==d->preloadfileram && !(e->flags&FHANDLE_FLAG_DESTROY_LATER)){
        assert(fhandle_virtualpath_equals(d,e));
        return true;
      }
    }
  }
  return false;
}
////////////////////////////////////////////////////////////////////////
///  rootdata may change by find_realpath_other_root()               ///
///  Check that preloadfileram is not NULL and that  root is still correct ///
////////////////////////////////////////////////////////////////////////
#define is_preloadfileram(d,r) _is_preloadfileram(d,r,__func__,__LINE__)
static bool _is_preloadfileram(const struct fHandle *d, const struct rootdata *r,const char *func,const int line){
  ASSERT_LOCKED_FHANDLE();
  if (!d || !d->preloadfileram || !d->preloadfileram->txtbuf){
    log_verbose("%s:%d !preloadfileram %s",func,line,d?D_VP(d):NULL);
    return false;
  }
  if (r && d->preloadfileram->m_zpath.root!=r){
    log_verbose("%s:%d wrong root %s",func,line,D_VP(d));
    return false;
  }
  return true;
}
/* Check whether d and  d->preloadfileram are not used by open file connections. */
static bool preloadfileram_can_break(const struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  return (d->flags&FHANDLE_FLAG_DESTROY_LATER) && !fhandle_currently_reading_writing(d)  && !is_preloadfileram_shared_with_other(d);
}
////////////////////////////////////////////////////////////////////////////////
/// Reading the cached bytes from the RAM                                    ///
/// Called from preloadfileram_wait_and_read(), fhandle_read_zip()  and xmp_read() ///
////////////////////////////////////////////////////////////////////////////////
static off_t preloadfileram_read(char *buf,const struct fHandle *d,const off_t from,off_t to){
  ASSERT_LOCKED_FHANDLE();
  if (!d || !d->preloadfileram || !d->preloadfileram->txtbuf) return -1;
  to=MIN(to,d->preloadfileram->preloadfileram_already);
  if (to==from) return 0; /* Note that returning -1 causes operation not permitted. */
  if (to>from){
    textbuffer_copy_to(d->preloadfileram->txtbuf,from,to,buf);
    return to-from;
  }
  return d->preloadfileram->preloadfileram_already<=from && d->preloadfileram->preloadfileram_status==preloadfileram_done?-1:0;
}

/* Invoked from xmp_read, where struct fHandle *d=fhandle_get(path,fd) */
static off_t preloadfileram_wait_and_read(char *buf, const off_t size, const off_t offset,struct fHandle *d,struct fuse_file_info *fi){
  //log_entered_function("%s ",D_VP(d));
  assert(d->zpath.root);
  root_start_thread(d->zpath.root,PTHREAD_PRELOAD,false);
  const bool ok=preloadfileram_wait(d,offset+size);
  LOCK_N(mutex_fhandle,const off_t preloadfileram_l=is_preloadfileram(d,NULL)? d->preloadfileram->preloadfileram_l: -1); /* Otherwise md5sum fails with EPERM */
  if (preloadfileram_l<0 || !ok) return -1;
  if (offset==preloadfileram_l) return 0;
  if (preloadfileram_l){
    LOCK_N(mutex_fhandle,const off_t num=preloadfileram_read(buf,d,offset,size+offset));
    if (num>0) COUNTER1_INC(COUNT_READZIP_PRELOADFILERAM);
    if (num>0 || preloadfileram_l>=offset) return num;
  }
  return -1;
}
////////////////////////////////////////////////////////////
/// After loading, compare with crc32 stored in ZIP file ///
////////////////////////////////////////////////////////////
static bool fhandle_check_crc32(struct fHandle *d){
  ASSERT_LOCKED_FHANDLE();
  if (!is_preloadfileram(d,NULL) || !d->preloadfileram->txtbuf->n) return false;
  const off_t st_size=d->zpath.stat_vp.st_size;
  const uint32_t crc=cg_crc32(textbuffer_first_segment(d->preloadfileram->txtbuf),st_size,0,_mutex+mutex_crc);
  if (d->zpath.zipcrc32!=crc){
    warning(WARN_PRELOADFILERAM|WARN_FLAG_ERROR,D_VP(d),"crc32-mismatch!  ZIP: %x != computed: %x size=%zu already: %zu  rp=%s",d->zpath.zipcrc32,crc,st_size,d->preloadfileram->preloadfileram_already,D_RP(d));
    return false;
  }
  //log_verbose(GREEN_SUCCESS"crc32  %x  size=%zu already: %zu  rp=%s",crc,st_size,d->preloadfileram->preloadfileram_already,D_RP(d));
  return true;
}
//////////////////////////////////////////////////////////////////////////////////////
/// When can copying bytes to RAM be interrupted?                                  ///
/// 1. flag FHANDLE_FLAG_DESTROY_LATER must be set                                 ///
/// 2. the fHandle instance is not used.                                           ///
/// 2. No other fHandle process is using the struct preloadfileram instance              ///
//////////////////////////////////////////////////////////////////////////////////////
static bool preloadfileram_store_try(struct fHandle *d, struct async_zipfile *zip, struct rootdata *r){
  //static int count;log_entered_function("%s  #%d",D_VP(d),++count);
  bool contin, ok;
  char rp[PATH_MAX];
  LOCK(mutex_fhandle,  if ((ok=contin=is_preloadfileram(d,r))) strcpy(rp,ZP_RP(&d->preloadfileram->m_zpath)));
  if (!ok) return false;
  const bool isZIP=d->zpath.flags&ZP_ZIP;
  const int fd=isZIP?0:open(rp,O_RDONLY);
  if (isZIP) openzip_now(zip);
  if (!zip->zf && fd<=0){ warning(WARN_PRELOADFILERAM|WARN_FLAG_ERRNO|WARN_FLAG_ERROR,rp,"Failed %s() d=%p",isZIP?"zip_open":"open",d); return false; }
  const off_t st_size=d->zpath.stat_vp.st_size;
  off_t already=0;
  LOCK(mutex_fhandle,if ((ok=contin=is_preloadfileram(d,r))) PRELOADFILE_ROOT_UPDATE_TIME(d,r,true));
  char *buf=cg_malloc(COUNT_PRELOADFILERAM_MALLOC,PRELOADFILERAM_READ_BYTES_NUM);
  for(;st_size>already;){
    const off_t n_max=MIN_long(PRELOADFILERAM_READ_BYTES_NUM,st_size-already);
    const off_t n=zip->zf?my_zip_fread(zip->zf,buf,n_max):read(fd,buf,n_max);
    if (n<=0){ ok=false; warning(WARN_PRELOADFILERAM,rp,"n<0  d=%p  read=%'zu st_size=%'ld",d,already,st_size); break;}
    { /* copy bytes */
      lock(mutex_fhandle);
      char *dst=NULL;
      if ((ok=contin=(is_preloadfileram(d,r) && !preloadfileram_can_break(d)))){
        dst=textbuffer_first_segment_with_min_capacity(st_size>SIZE_CUTOFF_MMAP_vs_MALLOC?TXTBUFSGMT_MUNMAP:0,d->preloadfileram->txtbuf,st_size);
        if ((ok=(dst!=NULL))){
          //          ASSERT(n<=PRELOADFILERAM_READ_BYTES_NUM);          ASSERT(already+n<=st_size);           ASSERT(fhandle_currently_reading_writing(d));
          memcpy(dst+already,buf,n);
          if ((already+=n)>d->preloadfileram->preloadfileram_already){
            d->preloadfileram->preloadfileram_already=already;
          }
          PRELOADFILE_ROOT_UPDATE_TIME(d,r,true);
        }
      }
      unlock(mutex_fhandle);
    }
    if (!ok) break;
  }/*for already*/
  cg_free(COUNT_PRELOADFILERAM_MALLOC,buf);
  const char *msg=NULL;
  if (already!=st_size){ /* Not Completely read */
    if (contin) msg=RED_WARNING" already!=st_size";
  }else if (isZIP){
    LOCK(mutex_fhandle, ok=fhandle_check_crc32(d));
    fhandle_counter_inc(d,ok?ZIP_READ_CACHE_CRC32_SUCCESS:ZIP_READ_CACHE_CRC32_FAIL);
    msg=ok?GREEN_SUCCESS" crc32 OK":RED_WARNING" already==st_size  crc32 wrong";
  }
  if (msg) IF_LOG_FLAG(LOG_PRELOADFILERAM)log_exited_function("%s  %s  st_size: %lld\n",rp,msg,(LLD)st_size);
  if (fd) close(fd); else closezip_now(zip);
  //log_exited_function("rp: %s  e: %s ok: %d  contin: %d",rp,D_EP(d),ok,contin);
  return ok;
}
//////////////////////////////////////////////////////////////////////
/// Try NUM_PRELOADFILERAM_STORE_RETRY times to run preloadfileram_store_try() ///
//////////////////////////////////////////////////////////////////////
static void preloadfileram_now(struct fHandle *d, struct rootdata *r){
  cg_thread_assert_not_locked(mutex_fhandle);
  const struct zippath *zpath=&d->zpath;
  log_entered_function("%s  textbuffer_memusage  head: %'lld ",VP(), (LLD)ramUsageForFilecontent());
  _Static_assert(NUM_PRELOADFILERAM_STORE_RETRY>0,"");
  FOR(retry,0,NUM_PRELOADFILERAM_STORE_RETRY){
    struct async_zipfile zip;
    bool ok,contin;
    LOCK(mutex_fhandle, if ((ok=contin=is_preloadfileram(d,r))) async_zipfile_init(&zip,&d->preloadfileram->m_zpath));
    if (!ok) break;
    if (retry){ log_verbose("Going to sleep 1s and retry  %s ...",VP()); usleep(1000*1000);} // cppcheck-suppress knownConditionTrueFalse
    const int64_t start=currentTimeMillis();
    if ((ok=preloadfileram_store_try(d,&zip,r))){
      lock(mutex_fhandle);
      if ((contin=is_preloadfileram(d,r))){
        d->preloadfileram->preloadfileram_took_mseconds=currentTimeMillis()-start;
        if(retry){ // && d->preloadfileram->preloadfileram_already==d->zpath.stat_vp.st_size
          warning(WARN_RETRY,VP(),"Success on retry %d",retry);fhandle_counter_inc(d,COUNT_RETRY_PRELOADFILERAM);
        }
      }
      unlock(mutex_fhandle);
    }
    if (!contin || ok){
      //log_exited_function("%s",VP());
      return;
    }
  }/*for retry*/
}
/////////////////////////////////////////////////////////////////////////////////
/// Directly set bytes to struct preloadfileram                                     ///
/// Needed for autogen and for getting the real file path with suffix @SOURCE ///
/////////////////////////////////////////////////////////////////////////////////
static bool fhandle_set_text(struct fHandle *d, struct textbuffer *b){
  ASSERT_LOCKED_FHANDLE();
  struct preloadfileram *m=preloadfileram_new(d);
  if (b==m->txtbuf) return true;
  if(m->txtbuf) return false; /* This can be triggered by special files */
  m->txtbuf=b;
  m->preloadfileram_already=m->preloadfileram_l=textbuffer_length(b);
  d->flags|=FHANDLE_FLAG_PRELOADFILERAM_COMPLETE;
  return true;
}



///////////////
/// Timeout ///
///////////////
/* If preloadfileram_async() has not been run before, start it.  Wait for completion of min_fill. */
static bool preloadfileram_wait(struct fHandle *d, const off_t min_fill){
  cg_thread_assert_not_locked(mutex_fhandle);
  assert(d->is_busy>0);
  assert(d->zpath.root!=NULL);
  {
    lock(mutex_fhandle);
    if (!d->preloadfileram){
      preloadfileram_new(d);
      d->preloadfileram->txtbuf=textbuffer_new(COUNT_MALLOC_PRELOADFILERAM_TXTBUF);
      preloadfileram_set_status(d,preloadfileram_queued);
      PRELOADFILE_ROOT_UPDATE_TIME(d,NULL,false);
    }
    unlock(mutex_fhandle);
  }
 again_with_other_root:
  for(int i=0;;i++){
    off_t a,preloadfileram_l;
    enum enum_preloadfileram_status status;
    bool ok;
#define F (a>=min_fill || a>=preloadfileram_l)
    LOCK(mutex_fhandle, ok=is_preloadfileram(d,NULL);  a=!ok?0:d->preloadfileram->preloadfileram_already; preloadfileram_l=!ok?0:d->preloadfileram->preloadfileram_l;status=!ok?0:d->preloadfileram->preloadfileram_status);
    if (!ok || F) return ok;
    if (status!=preloadfileram_reading && status!=preloadfileram_queued) return F;
#undef F
    if (preloadfile_time_exceeded(__func__,d,COUNT_PRELOADFILERAM_WAITFOR_TIMEOUT)) break;
    usleep(50+MIN(i,1<<18));
    if (!(i&1023)) fputc(status==preloadfileram_queued?'q':'r',stderr);
  }
  struct zippath zp={0};
  LOCK_N(mutex_fhandle, const bool ok=is_preloadfileram(d,NULL); if (ok) zp=d->preloadfileram->m_zpath);
  if (ok && find_realpath_other_root(&zp)){
    lock(mutex_fhandle);
    d->preloadfileram->m_zpath=zp;
    d->preloadfileram->preloadfileram_already=0;
    PRELOADFILE_ROOT_UPDATE_TIME(d,NULL,false);
    preloadfileram_set_status(d,preloadfileram_queued);
    unlock(mutex_fhandle);
    goto again_with_other_root;
  }/* i */
  return false;
}


// COUNT_MALLOC_PRELOADFILERAM_TXTBUF cg_free_null_malloc_id COUNT_S textbuffer   textbuffer_new(COUNT_MALLOC_PRELOADFILERAM_TXTBUF)
