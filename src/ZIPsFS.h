/////////////////////////////////////////////////////////////////
/// COMPILE_MAIN=ZIPsFS                                       ///
/// Enums and structs                                         ///
/////////////////////////////////////////////////////////////////




//////////////////////////////
/// Constants and Macros   ///
//////////////////////////////
#define WITH_SPECIAL_FILE WITH_PRELOADFILERAM
#define zpath_strcat(zpath,s)  zpath_strncat(zpath,s,9999)
#define ZPATH_COMMIT_HASH(zpath,x) zpath->x##_l=zpath_commit_hash(zpath,&zpath->x##_hash)
#define zpath_commit(zpath) zpath_commit_hash(zpath,NULL)
#define zpath_assert_strlen(zpath)  _zpath_assert_strlen(__func__,__FILE_NAME__,__LINE__,zpath)
#define Nth(array,i,defaultVal) (array?array[i]:defaultVal)
#define Nth0(array,i) Nth(array,i,0)

#define PROFILED(x) x

#define SIZE_POINTER sizeof(char *)
#define MAYBE_ASSERT(...) if (_killOnError) assert(__VA_ARGS__)
#define LOG_OPEN_RELEASE(path,...)
#define PATH_DOT_ZIPSFS "~/.ZIPsFS"
#define NUM_MUTEX   (mutex_roots+ROOTS)
#define DIRENT_ISDIR (1<<0)
#define DIRENT_IS_COMPRESSED (1<<1)
#define DIRENT_SAVE_MASK   (DIRENT_IS_COMPRESSED|DIRENT_ISDIR)
#define DIRENT_DIRECT_NAME (1<<2)
#define DIRENT_DIRECT_DEBUG (1<<3)
//#define DEBUG_DIRECTORY_HASH32_OF_FNAME(s)    hash32((char*)s->fname,s->files_l*sizeof(char*))

#define MALLOC_TYPE_SHIFT 8
#define MALLOC_TYPE_HT (1<<MALLOC_TYPE_SHIFT)
#define MALLOC_TYPE_KEYSTORE (2<<MALLOC_TYPE_SHIFT)
#define MALLOC_TYPE_VALUESTORE (3<<MALLOC_TYPE_SHIFT)
#define MALLOC_ID_COUNT (5<<MALLOC_TYPE_SHIFT)
#define CG_CLEANUP_BEFORE_EXIT() exit_ZIPsFS()

#if WITH_AUTOGEN || WITH_CCODE
#define WITH_AUTOGEN_OR_CCODE 1
#define htentry_fsize_for_inode(inode,create) ht_numkey_get_entry(&ht_fsize,inode,0,create)
#define htentry_fsize(vp,vp_l,create) htentry_fsize_for_inode(inode_from_virtualpath(vp,vp_l),create)
#else
#define WITH_AUTOGEN_OR_CCODE 0
#endif

/////////////
/// Files ///
/////////////

#define DIR_ZIPsFS             "/ZIPsFS"
#define DIR_ZIPsFS_L           (sizeof(DIR_ZIPsFS)-1)
#define DIR_PRELOADFILEDISK_R  DIR_ZIPsFS"/lr"
#define DIR_PRELOADFILEDISK_RC DIR_ZIPsFS"/lrc"
#define DIR_PRELOADFILEDISK_RZ DIR_ZIPsFS"/lrz"
#define DIR_AUTOGEN            DIR_ZIPsFS"/a"
#define DIR_AUTOGEN_L          (sizeof(DIR_AUTOGEN)-1)
#define DIR_INTERNET           DIR_ZIPsFS"/n"
#define DIR_INTERNET_L         (sizeof(DIR_INTERNET)-1)
#define DIR_INTERNET_GZ_L      (DIR_INTERNET_L+3)
#define FILENAME_SET_ATIME     "ZIPsFS_set_file_access_time"

#define DEBUG_ABORT_MISSING_TDF 1
#define IS_STAT_READONLY(st) !(st.st_mode&(S_IWUSR|S_IWGRP|S_IWOTH))


enum enum_functions{xmp_open_,xmp_access_,xmp_getattr_,xmp_read_,xmp_readdir_,functions_l};
enum enum_count_getattr{
  COUNTER_STAT_FAIL,COUNTER_STAT_SUCCESS,
  COUNTER_OPENDIR_FAIL,COUNTER_OPENDIR_SUCCESS,
  COUNTER_ZIPOPEN_FAIL,COUNTER_ZIPOPEN_SUCCESS,
  COUNTER_GETATTR_FAIL,COUNTER_GETATTR_SUCCESS,
  COUNTER_READDIR_SUCCESS,COUNTER_READDIR_FAIL,
  COUNTER_ROOTDATA_INITIALIZED,enum_count_getattr_length};
enum enum_counter_rootdata{
  ZIP_OPEN_SUCCESS,ZIP_OPEN_FAIL,
  //
  ZIP_READ_NOCACHE_SUCCESS,ZIP_READ_NOCACHE_ZERO, ZIP_READ_NOCACHE_FAIL,
  ZIP_READ_NOCACHE_SEEK_SUCCESS,ZIP_READ_NOCACHE_SEEK_FAIL,
  //
  ZIP_READ_CACHE_SUCCESS,ZIP_READ_CACHE_FAIL,
  ZIP_READ_CACHE_CRC32_SUCCESS,ZIP_READ_CACHE_CRC32_FAIL,
  //
  COUNT_RETRY_PRELOADFILERAM,
  //
  counter_rootdata_num};





#define SFILE_FLAG_REAL (1<<1)
#define SFILE_FLAG_OTHER_DIR (1<<2)
#define SPECIAL_FILE_IN_DEFAULT_DIR(i) (SPECIAL_FILES[i] && (SPECIAL_FILES_FLAGS[i]&SFILE_FLAG_OTHER_DIR)==0)


#define DEF_SPECIAL_FILES_AUTOGEN   C(SFILE_README_AUTOGEN,SFILE_FLAG_OTHER_DIR,"README_AUTOGENERATED.TXT")\
    C(SFILE_SET_ATIME_SH, 0,FILENAME_SET_ATIME".command")\
    C(SFILE_SET_ATIME_PS, 0,FILENAME_SET_ATIME".ps1")\
    C(SFILE_SET_ATIME_BAT,0,FILENAME_SET_ATIME".bat")\


#define DEF_SPECIAL_FILES    IF1(WITH_AUTOGEN,DEF_SPECIAL_FILES_AUTOGEN)\
       C(SFILE_LOG_WARNINGS,    SFILE_FLAG_REAL,                     "warnings.log")\
       C(SFILE_LOG_ERRORS,      SFILE_FLAG_REAL,                     "errors.log")\
       C(SFILE_INFO,            0,                                   "file_system_info.html")\
       C(SFILE_CLEAR_CACHE,     0,                                   "ZIPsFS_clear_cache.command")\
       C(SFILE_README,          0,                                   "README_ZIPsFS.html")\
       C(SFILE_DEBUG_CTRL,      SFILE_FLAG_REAL|SFILE_FLAG_OTHER_DIR,NULL)\
       C(SFILE_README_INTERNET,   SFILE_FLAG_OTHER_DIR,                "README_ZIPsFS.TXT")\
       C(SFILE_README_PRELOADFILEDISK, SFILE_FLAG_OTHER_DIR,           "README_ZIPsFS.TXT")




#define C(id,...) id,
enum enum_special_files{SFILE_NIL,   DEF_SPECIAL_FILES    SFILE_DIR_ZIPsFS,SFILE_NUM};
#undef C
static char *SPECIAL_FILES[SFILE_NUM];
static int SPECIAL_FILES_L[SFILE_NUM];
static int SPECIAL_FILES_FLAGS[SFILE_NUM];
static void special_filename_init(){
#define C(id,flags,name) SPECIAL_FILES_FLAGS[id]=flags; SPECIAL_FILES_L[id]=sizeof(name)-1; SPECIAL_FILES[id]=name;
  DEF_SPECIAL_FILES
#undef C
    }




// #define IS_IN_DIR_AUTOGEN(vp,vp_l)    (vp_l >DIR_AUTOGEN_L+1    && vp[DIR_ZIPsFS_L]=='/' &&  vp[DIR_AUTOGEN_L]=='/'    && STARTSWITH(vp,DIR_AUTOGEN))

#define IS_IN_DIR_ZIPsFS(vp,vp_l)     (vp_l>DIR_ZIPsFS_L+1      && vp[DIR_ZIPsFS_L]=='/' &&                               STARTSWITH(vp,DIR_ZIPsFS))
#define IS_IN_DIR_Z(dir,vp,vp_l)      (vp_l>sizeof(dir) && vp[DIR_ZIPsFS_L]=='/' &&  vp[sizeof(dir)-1]=='/' && STARTSWITH(vp,dir))
#define IS_DIR_ZIPsFS(vp,vp_l)        (vp_l==DIR_ZIPsFS_L&&!strcmp(vp,DIR_ZIPsFS))
#define IS_DIR_Z(dir,vp,vp_l)    (vp_l==sizeof(dir)-1 && vp[DIR_ZIPsFS_L]=='/' && !memcmp(vp,dir,sizeof(dir)-1))




enum enum_autogen_state{AUTOGEN_UNINITILIZED,AUTOGEN_SUCCESS,AUTOGEN_FAIL};
///////////////////////////////////////
/// Enums and corresponding strings ///
///////////////////////////////////////
#define A1() C(HT_MALLOC_UNDEFINED)C(HT_MALLOC_warnings)C(HT_MALLOC_ht_count_by_ext)C(HT_MALLOC_file_ext)C(HT_MALLOC_inodes)C(HT_MALLOC_transient_cache)C(HT_MALLOC_without_dups)C(HT_MALLOC_LEN)
#define A3() C(WARN_INIT)C(WARN_MISC)C(WARN_CONFIG)C(WARN_STR)C(WARN_INODE)C(WARN_THREAD)C(WARN_MALLOC)C(WARN_ROOT)C(WARN_OPEN)C(WARN_READ)C(WARN_ZIP_FREAD)C(WARN_READDIR)C(WARN_SEEK)C(WARN_ZIP)C(WARN_GETATTR)C(WARN_STAT)C(WARN_FHANDLE)C(WARN_DIRCACHE) C(WARN_PRELOADFILE) C(WARN_PRELOADFILERAM) C(WARN_PRELOADFILEDISK)C(WARN_FORMAT)C(WARN_DEBUG)C(WARN_CHARS)C(WARN_RETRY)C(WARN_AUTOGEN)C(WARN_C)C(WARN_NET)C(WARN_LEN)
#define A4(x) C(preloadfileram_status_nil)C(preloadfileram_queued)C(preloadfileram_reading)C(preloadfileram_done)C(PRELOADFILERAM_STATUS_NUM)
#define A5() C(PRELOADFILERAM_NEVER)C(PRELOADFILERAM_SEEK)C(PRELOADFILERAM_RULE)C(PRELOADFILERAM_COMPRESSED)C(PRELOADFILERAM_ALWAYS)
#define A7(x) C(PTHREAD_NIL)C(PTHREAD_ASYNC)C(PTHREAD_PRELOAD)C(PTHREAD_MISC)C(PTHREAD_LEN)
#define A8(x) C(mutex_nil)C(mutex_start_thread)C(mutex_fhandle)C(mutex_async)C(mutex_mutex_count)C(mutex_mstore_init)C(mutex_autogen_init)C(mutex_dircache_queue)C(mutex_log_count)C(mutex_crc)C(mutex_inode)C(mutex_memUsage)C(mutex_dircache)C(mutex_idx)C(mutex_validchars)C(mutex_special_file)C(mutex_validcharsdir)C(mutex_textbuffer_usage)C(mutex_roots)C(mutex_len) //* mutex_roots must be last */

#define A9(x) C(LOG_DEACTIVATE_ALL)C(LOG_FUSE_METHODS_ENTER)C(LOG_FUSE_METHODS_EXIT)C(LOG_ZIP)C(LOG_ZIP_INLINE)C(LOG_EVICT_FROM_CACHE)C(LOG_PRELOADFILERAM)C(LOG_REALPATH)C(LOG_AUTOGEN)C(LOG_READ_BLOCK)\
       C(LOG_TRANSIENT_ZIPENTRY_CACHE)\
       C(LOG_STAT)C(LOG_OPEN)C(LOG_OPENDIR)\
       C(LOG_INFINITY_LOOP_RESPONSE)C(LOG_INFINITY_LOOP_STAT)C(LOG_INFINITY_LOOP_PRELOADFILERAM)C(LOG_INFINITY_LOOP_DIRCACHE)C(LOG_INFINITY_LOOP_MISC)  C(LOG_FLAG_LENGTH)

#define A10(x) C(ASYNC_NIL)C(ASYNC_STAT)C(ASYNC_READDIR)C(ASYNC_OPENFILE)C(ASYNC_OPENZIP)   C(ASYNC_LENGTH)


#define A12() C(COUNT_UNDEFINED) C(COUNT_MALLOC_TESTING)\
       C(COUNT_HT_MALLOC_TRANSIENT_CACHE)C(COUNT_MALLOC_KEY_TRANSIENT_CACHE)\
       C(COUNT_HT_MALLOC_MISMATCH)C(COUNT_HT_MALLOC_KEY_MISMATCH)\
       C(COUNT_HT_MALLOC_NODUPS)\
       C(COUNT_MSTORE_MMAP_NODUPS) C(COUNT_MSTORE_MALLOC_NODUPS)\
       C(COUNTm_MSTORE_MMAP)                C(COUNTm_MSTORE_MALLOC)\
       C(COUNTER_TXTBUFSGMT_MMAP) C(COUNTER_TXTBUFSGMT_MALLOC)\
       C(COUNT_TXTBUF_SEGMENT_MALLOC)  C(COUNT_TXTBUF_SEGMENT_MMAP)\
       C(COUNT_MSTORE_MMAP_DIR_FILENAMES)           C(COUNT_MSTORE_MALLOC_DIR_FILENAMES)\
  C(COUNT_MSTORE_MMAP_TRANSIENT_CACHE_VALUES)       C(COUNT_MSTORE_MALLOC_TRANSIENT_CACHE_VALUES)\
  C(COUNT_HT_MALLOC_KEY)\
  C(COUNT_AUTOGEN_MALLOC_replacements)\
  C(COUNT_AUTOGEN_MALLOC_argv)\
  C(COUNT_AUTOGEN_MALLOC_TXTBUF)\
  C(COUNT_MALLOC_dir_field)\
  C(COUNT_MALLOC_dircachejobs)\
  C(COUNT_PRELOADFILERAM_MALLOC)\
  C(COUNT_MALLOC_PRELOADFILERAM_TXTBUF)\
  C(COUNT_ZIP_OPEN)\
  C(COUNT_ZIP_FOPEN)\
  C(COUNT_FHANDLE_CONSTRUCT)\
  C(COUNTm_FHANDLE_ARRAY_MALLOC)\
  C(COUNT_FHANDLE_TRANSIENT_CACHE)\
       C(COUNT_PAIRS_END)\
\
       C(COUNT_PRELOADFILERAM_WAITFOR_TIMEOUT)\
  C(COUNT_LCOPY_WAITFOR_TIMEOUT)\
       C(COUNT_READZIP_PRELOADFILERAM)\
       C(COUNT_READZIP_PRELOADFILERAM_BECAUSE_SEEK_BWD)\
  C(COUNT_STAT_FROM_CACHE)\
       C(COUNT_PTHREAD_LOCK)\
  C(COUNT_SEQUENTIAL_INODE)\
  C(COUNT_NUM)


#define A13() C(ACT_NIL)C(ACT_KILL_ZIPSFS)C(ACT_FORCE_UNBLOCK)C(ACT_CANCEL_THREAD)C(ACT_NO_LOCK)C(ACT_BAD_LOCK)C(ACT_CLEAR_CACHE)C(ACT_LEN)



#define C(a) a,
enum enum_mstoreid{A1()};
enum enum_mallocid{A12()};
enum enum_ctrl_action{A13()};
enum enum_warnings{A3()};
#if WITH_PRELOADFILERAM
enum enum_preloadfileram_status{A4()};
enum enum_when_preloadfileram_zip{A5()};
#endif //WITH_PRELOADFILERAM
enum enum_root_thread{A7()};
enum enum_mutex{A8()};
enum enum_log_flags{A9()};
enum enum_async{A10()};
#undef C
#define C(a) #a,
static const char *HT_MALLOC_S[]={A1()NULL};
static const char *COUNT_S[]={A12()NULL};
static const char *CTRL_ACTION_S[]={A13()NULL};
static const char *MY_WARNING_NAME[]={A3()NULL};
IF1(WITH_PRELOADFILERAM,static const char *PRELOADFILERAM_STATUS_S[]={A4()NULL});
IF1(WITH_PRELOADFILERAM,static const char *WHEN_PRELOADFILERAM_S[]={A5()NULL});
static const char *PTHREAD_S[]={A7()NULL};
static const char *MUTEX_S[]={A8()NULL};
static const char *LOG_FLAG_S[]={A9()NULL};
static const char *ASYNC_S[]={A10()NULL};
#undef C
#undef A1

#undef A3
#undef A4
#undef A5
//#undef A6
#undef A7
#undef A8
#undef A9
#undef A10

#undef A11
#undef A12
#undef A13
#undef A14



struct counter_rootdata{
  const char *ext;
  atomic_uint counts[counter_rootdata_num];
  long rank;
  clock_t wait;
};
typedef struct counter_rootdata counter_rootdata_t;


struct autogen_files;
// ---

#if ! WITH_DIRCACHE
#undef WITH_ZIPINLINE
#define WITH_ZIPINLINE 0
#undef WITH_ZIPENTRY_PLACEHOLDER
#define WITH_ZIPENTRY_PLACEHOLDER 0
#undef WITH_ZIPINLINE_CACHE
#define WITH_ZIPINLINE_CACHE 0
#endif
// ---
#if ! WITH_ZIPINLINE
#undef WITH_ZIPINLINE_CACHE
#define WITH_ZIPINLINE_CACHE 0
#endif
// ---
#define C_FILE_DATA()    C(fname,char *); C(fsize,off_t);  C(fmtime,uint64_t); C(fcrc,uint32_t); C(fflags,uint8_t); C(finode,uint64_t);
#define C(field,type) type *field;
struct directory_core{
  struct timespec dir_mtim;
  int files_l;
  C_FILE_DATA();
};
#undef C










// ---
////////////////
/// zippath  ///
////////////////
struct zippath{
#define C(s) int s,s##_l
  char strgs[ZPATH_STRGS];  int strgs_l; /* Contains all strings: virtualpath virtualpath_without_entry, entry_path and finally realpath */
  C(virtualpath); /* The path in the FUSE fs relative to the mount point */
  C(virtualpath_without_entry);  /*  Let Virtualpath be "/foo.zip.Content/bar". virtualpath_without_entry will be "/foo.zip.Content". */
  C(entry_path); /* Let Virtualpath be "/foo.zip.Content/bar". entry_path will be "bar". */
  C(realpath); /* The physical path of the file. In case of a ZIP entry, the path of the ZIP-file */
#undef C
  ht_hash_t virtualpath_hash,virtualpath_without_entry_hash,realpath_hash;
  zip_uint32_t zipcrc32;
  struct rootdata *root;
  int current_string; /* The String that is currently build within strgs with zpath_newstr().  With zpath_commit() this marks the end of String. */
  struct stat stat_rp,stat_vp;
  uint32_t flags;
};


struct async_zipfile{
  zip_file_t *zf;
  struct zip *za;
  struct zippath azf_zpath;
} static const async_zipfile_empty;


#define DIRECTORY_DIM_STACK IF01(WITH_TESTING_REALLOC,4,MAX(256,ULIMIT_S))
struct directory{
  STRUCT_NOT_ASSIGNABLE();
  struct zippath dir_zpath;
#define DIR_RP(dir)      ((dir)->dir_zpath.strgs+(dir)->dir_zpath.realpath)
#define DIR_RP_L(dir)    ((dir)->dir_zpath.realpath_l)
#define DIR_VP(dir)      ((dir)->dir_zpath.strgs+(dir)->dir_zpath.virtualpath)
#define DIR_VP_L(dir)    ((dir)->dir_zpath.virtualpath_l)
#define DIR_ROOT(dir)    ((dir)->dir_zpath.root)
#define DIR_IS_ZIP(dir) (((dir)->dir_zpath.flags&ZP_ZIP)!=0)
#define C(field,type) type _stack_##field[DIRECTORY_DIM_STACK];
  C_FILE_DATA();
#undef C
  struct directory_core core; // Only this data goes to dircache.
  struct mstore filenames;
  int files_capacity,cached_vp_to_zip;
  bool debug, dir_is_dircache, dir_is_destroyed, dir_is_success, has_file_containing_placeholder;
  /* The following concern asynchronized reading */
  bool async_never;
  IF1(WITH_TIMEOUT_READDIR, struct ht *ht_intern_names);
};

#define ROOT_WHEN_SUCCESS(r,t) atomic_load(r->thread_when_success+t)
#define ROOT_WHEN_ITERATED(r,t) atomic_load(r->thread_when+t)

#define ROOT_SUCCESS_SECONDS_AGO(r) (time(NULL)-ROOT_WHEN_SUCCESS(r,PTHREAD_ASYNC))
#define ROOT_NOT_RESPONDING(r)  (r->remote && ROOT_SUCCESS_SECONDS_AGO(r)>ROOT_RESPONSE_WITHIN_SECONDS)


#define ZP_STARTS_AUTOGEN       (1<<2)
#define ZP_ZIP                  (1<<3)
#define ZP_DOES_NOT_EXIST       (1<<4)
#define ZP_IS_COMPRESSED        (1<<5)
#define ZP_FROM_TRANSIENT_CACHE (1<<6)
#define ZP_PRELOADFILEDISK      (1<<7)



#define ZPATH_IS_ZIP() ((zpath->flags&ZP_ZIP)!=0)
#define ZPATH_ROOT_WRITABLE() (zpath->root && 0!=(zpath->root->writable))
#define LOG_FILE_STAT() cg_log_file_stat(zpath->realpath,&zpath->stat_rp),log_file_stat(zpath->virtualpath,&zpath->stat_vp)
//#define VP() (zpath->strgs+zpath->virtualpath)
#define EP() (zpath->strgs+zpath->entry_path)
#define EP_L() zpath->entry_path_l
#define VP_L() zpath->virtualpath_l
#define ZP_RP(zpath) ((zpath)->strgs+(zpath)->realpath)
#define ZP_VP(zpath) ((zpath)->strgs+(zpath)->virtualpath)

#define RP() ZP_RP(zpath)
#define VP() ZP_VP(zpath)

//#define RP() ZP_RP(zpath)

#define RP_L() (zpath->realpath_l)
#define VP0() (zpath->strgs+zpath->virtualpath_without_entry)
#define VP0_L() zpath->virtualpath_without_entry_l
#define D_VP(d) (d->zpath.strgs+d->zpath.virtualpath)
#define D_VP0(d) (d->zpath.strgs+d->zpath.virtualpath_without_entry)
#define D_VP0(d) (d->zpath.strgs+d->zpath.virtualpath_without_entry)
#define D_VP_HASH(d) d->zpath.virtualpath_hash
#define D_EP(d) (d->zpath.strgs+d->zpath.entry_path)
#define D_EP_L(d) d->zpath.entry_path_l
#define D_VP_L(d) d->zpath.virtualpath_l
#define D_RP(d) (d->zpath.strgs+d->zpath.realpath)
#define D_RP_HASH(d) (d->zpath.realpath_hash)
#define D_RP_L(d) (d->zpath.realpath_l)
#define NEW_ZIPPATH(virtpath)  struct zippath __zp={0},*zpath=&__zp;zpath_init(zpath,virtpath)
#define FIND_REALPATH(virtpath)    NEW_ZIPPATH(virtpath);  found=find_realpath_any_root(0,zpath,NULL);
////////////////////////////////////////////////////////////////////////////////////////////////////
///   The struct fHandle "file handle" holds data associated with a file descriptor.
///   They are stored in the linear list _fhandle. The list may have holes.
///   Preloadfileram: It may also contain the cached file content of the zip entry.
///   Only one of all instances with a specific virtual path should store the cached zip entry
////////////////////////////////////////////////////////////////////////////////////////////////////




#define FINDRP_AUTOGEN_CUT (1<<1)
#define FINDRP_AUTOGEN_CUT_NOT (1<<2)
#define FINDRP_NOT_TRANSIENT_CACHE (1<<3)
#define FILETYPEDATA_NUM 1024
#define FILETYPEDATA_FREQUENT_NUM 64
// #define foreach_fhandle_also_emty(id,d) int id=_fhandle_n;for(struct fHandle *d;--id>=0 && ((d=fhandle_at_index(id))||true);)

#define foreach_fhandle_also_emty(id,d) struct fHandle *d; for(int id=_fhandle_n;--id>=0 && ((d=fhandle_at_index(id))||true);)
#define fhandle_virtualpath_equals(d,e) (d!=e && D_VP_HASH(e)==D_VP_HASH(d) && !strcmp(D_VP(d),D_VP(e)))
#define fhandle_zip_ftell(d) d->zip_fread_position
// cppcheck-suppress-macro constVariablePointer
#define foreach_fhandle(id,d)  foreach_fhandle_also_emty(id,d) if (d->flags)




/* flags for config_file_attribute_valid_seconds() */
#define STAT_CACHE_FILE_IS_READONLY (1<<2)
#define STAT_CACHE_ROOT_IS_REMOTE   (1<<3)
#define STAT_CACHE_ROOT_IS_WRITABLE (1<<4)

#define FHANDLE_LOG2_BLOCK_SIZE 5
#define FHANDLE_BLOCKS 512
#define FHANDLE_BLOCK_SIZE (1<<FHANDLE_LOG2_BLOCK_SIZE)
#define FHANDLE_MAX (FHANDLE_BLOCKS*FHANDLE_BLOCK_SIZE)

struct fHandle{
  uint64_t fh, fh_real;
  struct zip *zip_archive;
  zip_file_t *zip_file;
  struct zippath zpath;
  volatile time_t accesstime;
  volatile int flags;
#define FHANDLE_FLAG_ACTIVE                         (1<<0)
#define FHANDLE_FLAG_DESTROY_LATER                  (1<<1)
#define FHANDLE_FLAG_OPEN_LATER_IN_READ_OR_WRITE    (1<<2)
#define FHANDLE_FLAG_SEEK_FW_FAIL                   (1<<3)
#define FHANDLE_FLAG_SEEK_BW_FAIL                   (1<<4)
#define FHANDLE_FLAG_WITH_TRANSIENT_ZIPENTRY_CACHES (1<<5) /* Can attach ht_transient_cache */
#define FHANDLE_FLAG_IS_AUTOGEN                     (1<<6)
#define FHANDLE_FLAG_WITH_PRELOADFILERAM                  (1<<8)
#define FHANDLE_FLAG_WITHOUT_PRELOADFILERAM               (1<<9)
#define FHANDLE_FLAG_PRELOADFILERAM_COMPLETE              (1<<10)
#define FHANDLE_FLAG_SPECIAL_FILE                   (1<<11)
#define FHANDLE_FLAG_IS_CCODE                       (1<<12)
#define FHANDLE_FLAG_LCOPY_QUEUE                    (1<<13)
#define FHANDLE_FLAG_LCOPY_RUN                      (1<<13)
  //#define FHANDLE_FLAG_NOT_CCODE                  (1<<15)
  uint8_t already_logged;
  volatile int64_t offset,n_read;
  volatile atomic_int is_busy; /* Increases when entering xmp_read. If greater 0 then the instance must not be destroyed. */
  pthread_mutex_t mutex_read; /* Costs 40 Bytes */
  counter_rootdata_t *filetypedata;
  off_t zip_fread_position;
  IF1(WITH_TRANSIENT_ZIPENTRY_CACHES,struct ht *ht_transient_cache);
  IF1(WITH_PRELOADFILERAM, struct preloadfileram * volatile preloadfileram);
  atomic_int volatile is_preloading;
  IF1(WITH_AUTOGEN,enum enum_autogen_state autogen_state; int autogen_error);
} static const FHANDLE_EMPTY;

/////////////////////////////////////////////////////////////////////////
///  Union file system:
///  struct rootdata holds the data for a branch
///  This is the root path  of an upstream source file tree.
///  ZIPsFS is a union file system and combines all source directories
//////////////////////////////////////////////////////////////////////////
#define foreach_root(r)    for(struct rootdata *r=_root; r<_root+_root_n; r++)
struct rootdata{
  char rootpath[MAX_PATHLEN+1],rootpath_mountpoint[MAX_PATHLEN+1];
  char retain_dirname[MAX_PATHLEN+1]; /* last path component with a leading slash without trailing slash   or "" */
  int rootpath_l,retain_dirname_l;
  struct statvfs statvfs;
  uint32_t log_count_delayed,log_count_delayed_periods,log_count_restarted;
  struct ht dircache_queue,dircache_ht,ht_inodes; // !!
#if WITH_DIRCACHE || WITH_STAT_CACHE || WITH_TIMEOUT_READDIR
  struct ht dircache_ht_fname, dircache_ht_fnamearray;
  struct mstore dircache_mstore;
#endif
  struct ht ht_filetypedata;
  pthread_t thread[PTHREAD_LEN];
  int thread_count_started[PTHREAD_LEN];
  int thread_when_canceled[PTHREAD_LEN];
  //  atomic_int thread_starting[PTHREAD_LEN];


  pid_t thread_pid[PTHREAD_LEN];
  counter_rootdata_t filetypedata_dummy,filetypedata_all, filetypedata[FILETYPEDATA_NUM],filetypedata_frequent[FILETYPEDATA_FREQUENT_NUM];
  bool filetypedata_initialized, blocked, writable, remote,preload,with_timeout,thread_already_started[PTHREAD_LEN];
  int seq_fsid;
  unsigned long f_fsid; /* From statvfs.f_fsid */
  pthread_mutex_t async_mtx[ASYNC_LENGTH];
  int async_go[ASYNC_LENGTH];
  int async_task_id[ASYNC_LENGTH];
  volatile atomic_ulong thread_when[PTHREAD_LEN],thread_when_success[PTHREAD_LEN]; _Static_assert(sizeof(atomic_ulong)>=sizeof(time_t),"");
  IF1(WITH_TIMEOUT_OPENFILE,int  async_openfile_fd,async_openfile_flags;  char async_openfile_path[MAX_PATHLEN+1]);
  IF1(WITH_TIMEOUT_STAT,    struct stat async_stat;  struct strg async_stat_path);
  IF1(WITH_TIMEOUT_READDIR, struct directory *async_dir);
  IF1(WITH_TIMEOUT_OPENZIP, struct async_zipfile *async_zipfile);
};



///////////////
/// Logging ///
///////////////

#if 1
#define LOG_FLAG_P(f)  (f && _log_flags&(1<<f))
#else
// Initiates excessive logging
#define LOG_FLAG_P(f)  (f && (LOG_OPENDIR|LOG_READ_BLOCK|LOG_STAT|LOG_OPENDIR|LOG_PRELOADFILERAM)&(1<<f))
#endif







#define IF_LOG_FLAG(f) if (LOG_FLAG_P(f))
#define IF_LOG_FLAG_OR(f,or) if (LOG_FLAG_P(f)||or)


#define LOG_FUSE(path)          IF_LOG_FLAG(LOG_FUSE_METHODS_ENTER)log_entered_function("%s",path)
#define LOG_FUSE_RES(path,res)  IF_LOG_FLAG(LOG_FUSE_METHODS_ENTER)log_exited_function("%s res:%d",path,res)
//#define LOG_FUSE(path)log_entered_function("%s",path)
//#define LOG_FUSE_RES(path,res)log_exited_function("%s res:%d",path,res)

//
#define ADVISE_DIRCACHE_IS_ZIP              (1<<1)
#define ADVISE_DIRCACHE_IS_REMOTE           (1<<2)
//
#define ADVISE_CACHE_IS_CMPRESSED           (1<<1) /* This  ZIP entry is compressed. */
#define ADVISE_CACHE_IS_SEEK_BW             (1<<2) /* There is currently an atempt to seek backward. This is inefficient for compressed ZIP entries. */
#define ADVISE_CACHE_BY_POLICY              (1<<3)
#define ADVISE_CACHE_IS_ZIPENTRY            (1<<4)
//
#if WITH_PRELOADFILERAM
struct preloadfileram{
  volatile enum enum_preloadfileram_status preloadfileram_status;
  struct textbuffer *txtbuf;
  struct zippath m_zpath; /* To try find_realpath_other_root() */
  volatile off_t preloadfileram_l,preloadfileram_already;
  int64_t preloadfileram_took_mseconds;
  int id;
};
#endif // WITH_PRELOADFILERAM


#define  PRELOADFILE_ROOT_UPDATE_TIME(d,r,success)   if (d || r) root_update_time(r?r:d->zpath.root,success?PTHREAD_PRELOAD:-PTHREAD_PRELOAD)

////////////////////
/// Directories  ///
////////////////////
#define FILLDIR_AUTOGEN (1<<0)
#define FILLDIR_IS_DIR_ZIPsFS (1<<1)
#define FILLDIR_STRIP_NET_HEADER (1<<2)
//#define filler_add(filler,buf,name,st,no_dups) {if (ht_only_once(no_dups,name,0)){ filler(buf,name,st,0 COMMA_FILL_DIR_PLUS); cg_log_file_stat(name,st);}}
//#define filler_add(filler,buf,name,st,no_dups) {if (ht_only_once(no_dups,name,0)) filler(buf,name,st,0 COMMA_FILL_DIR_PLUS);}
#define stat_direct(...) _stat_direct(__VA_ARGS__,__func__)
