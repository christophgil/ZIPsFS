/////////////////////////////////////////////////////////////////
/// COMPILE_MAIN=ZIPsFS                                       ///
/// Enums and structs                                         ///
/////////////////////////////////////////////////////////////////




//////////////////////////////
/// Constants and Macros   ///
//////////////////////////////
#define WITH_SPECIAL_FILE WITH_MEMCACHE
#define zpath_strcat(zpath,s)  zpath_strncat(zpath,s,9999)
#define ZPATH_COMMIT_HASH(zpath,x) zpath->x##_l=zpath_commit_hash(zpath,&zpath->x##_hash)
#define zpath_commit(zpath) zpath_commit_hash(zpath,NULL)
#define zpath_assert_strlen(zpath)  _zpath_assert_strlen(__func__,__FILE_NAME__,__LINE__,zpath)
#define Nth(array,i,defaultVal) (array?array[i]:defaultVal)
#define Nth0(array,i) Nth(array,i,0)

#define PROFILED(x) x

#define SIZE_POINTER sizeof(char *)
#define MAYBE_ASSERT(...) if (_killOnError) assert(__VA_ARGS__)
#define LOG_OPEN_RELEASE(path,...)
#define PATH_DOT_ZIPSFS "~/.ZIPsFS"
#define NUM_MUTEX   (mutex_roots+ROOTS)
#define DIRENT_ISDIR (1<<0)
#define DIRENT_IS_COMPRESSED (1<<1)
//#define DEBUG_DIRECTORY_HASH32_OF_FNAME(s)    hash32((char*)s->fname,s->files_l*sizeof(char*))

#define MALLOC_TYPE_SHIFT 8
#define MALLOC_TYPE_HT (1<<MALLOC_TYPE_SHIFT)
#define MALLOC_TYPE_KEYSTORE (2<<MALLOC_TYPE_SHIFT)
#define MALLOC_TYPE_VALUESTORE (3<<MALLOC_TYPE_SHIFT)
#define MALLOC_ID_COUNT (5<<MALLOC_TYPE_SHIFT)
#define CG_CLEANUP_BEFORE_EXIT() exit_ZIPsFS()

#if WITH_AUTOGEN || WITH_CCODE
#define WITH_AUTOGEN_OR_CCODE 1
#define htentry_fsize_for_inode(inode,create) ht_numkey_get_entry(&ht_fsize,inode,0,create)
#define htentry_fsize(vp,vp_l,create) htentry_fsize_for_inode(inode_from_virtualpath(vp,vp_l),create)
#else
#define WITH_AUTOGEN_OR_CCODE 0
#endif

/////////////
/// Files ///
/////////////
#define DIR_ZIPsFS "/ZIPsFS"
#define DIR_ZIPsFS_L (sizeof(DIR_ZIPsFS)-1)
#define DIRNAME_AUTOGEN "a"
#define DIR_AUTOGEN DIR_ZIPsFS"/"DIRNAME_AUTOGEN
#define DIR_AUTOGEN_L (sizeof(DIR_AUTOGEN)-1)

#define DIRNAME_INTERNET "n"
#define DIR_INTERNET DIR_ZIPsFS"/"DIRNAME_INTERNET
#define DIR_INTERNET_L (sizeof(DIR_INTERNET)-1)


#define FILENAME_SET_ATIME "ZIPsFS_set_file_access_time"

#define PLACEHOLDER_NAME 0x07
//#define PLACEHOLDER_NAME '*'
#define DEBUG_ABORT_MISSING_TDF 1
#define IS_STAT_READONLY(st) !(st.st_mode&(S_IWUSR|S_IWGRP|S_IWOTH))


enum enum_functions{xmp_open_,xmp_access_,xmp_getattr_,xmp_read_,xmp_readdir_,functions_l};
enum enum_count_getattr{
  COUNTER_STAT_FAIL,COUNTER_STAT_SUCCESS,
  COUNTER_OPENDIR_FAIL,COUNTER_OPENDIR_SUCCESS,
  COUNTER_ZIPOPEN_FAIL,COUNTER_ZIPOPEN_SUCCESS,
  COUNTER_GETATTR_FAIL,COUNTER_GETATTR_SUCCESS,
  COUNTER_ACCESS_FAIL,COUNTER_ACCESS_SUCCESS,
  COUNTER_READDIR_SUCCESS,COUNTER_READDIR_FAIL,
  COUNTER_ROOTDATA_INITIALIZED,enum_count_getattr_length};
enum enum_counter_rootdata{
  ZIP_OPEN_SUCCESS,ZIP_OPEN_FAIL,
  //
  ZIP_READ_NOCACHE_SUCCESS,ZIP_READ_NOCACHE_ZERO, ZIP_READ_NOCACHE_FAIL,
  ZIP_READ_NOCACHE_SEEK_SUCCESS,ZIP_READ_NOCACHE_SEEK_FAIL,
  //
  ZIP_READ_CACHE_SUCCESS,ZIP_READ_CACHE_FAIL,
  ZIP_READ_CACHE_CRC32_SUCCESS,ZIP_READ_CACHE_CRC32_FAIL,
  //
  COUNT_RETRY_STAT,
  COUNT_RETRY_MEMCACHE,
  //
  counter_rootdata_num};





#define SFILE_FLAG_REAL (1<<1)
#define SFILE_FLAG_OTHER_DIR (1<<2)
#define SPECIAL_FILE_IN_DEFAULT_DIR(i) (SPECIAL_FILES[i] && (SPECIAL_FILES_FLAGS[i]&SFILE_FLAG_OTHER_DIR)==0)


#define DEF_SPECIAL_FILES_AUTOGEN   C(SFILE_AUTOGEN_README,SFILE_FLAG_OTHER_DIR,"README_AUTOGENERATED.TXT")\
    C(SFILE_SET_ATIME_SH, 0,FILENAME_SET_ATIME".command")\
    C(SFILE_SET_ATIME_PS, 0,FILENAME_SET_ATIME".ps1")\
    C(SFILE_SET_ATIME_BAT,0,FILENAME_SET_ATIME".bat")\


#define DEF_SPECIAL_FILES    IF1(WITH_AUTOGEN,DEF_SPECIAL_FILES_AUTOGEN)\
       C(SFILE_LOG_WARNINGS,    SFILE_FLAG_REAL,                     "warnings.log")\
       C(SFILE_LOG_ERRORS,      SFILE_FLAG_REAL,                     "errors.log")\
       C(SFILE_INFO,            0,                                   "file_system_info.html")\
       C(SFILE_CLEAR_CACHE,     0,                                   "ZIPsFS_clear_cache.command")\
       C(SFILE_README,          0,                                   "Readme_ZIPsFS.html")\
       C(SFILE_DEBUG_CTRL,      SFILE_FLAG_REAL|SFILE_FLAG_OTHER_DIR,NULL)\
       C(SFILE_INTERNET_README, SFILE_FLAG_OTHER_DIR,                "README.TXT")




#define C(id,...) id,
enum enum_special_files{SFILE_NIL,   DEF_SPECIAL_FILES    SFILE_DIR_ZIPsFS,SFILE_NUM};
#undef C
static char *SPECIAL_FILES[SFILE_NUM];
static int SPECIAL_FILES_L[SFILE_NUM];
static int SPECIAL_FILES_FLAGS[SFILE_NUM];
static void special_filename_init(){
#define C(id,flags,name) SPECIAL_FILES_FLAGS[id]=flags; SPECIAL_FILES_L[id]=sizeof(name)-1; SPECIAL_FILES[id]=name;
  DEF_SPECIAL_FILES
#undef C
    }

#define IS_IN_DIR_ZIPsFS(vp,vp_l)  (vp_l>DIR_ZIPsFS_L+1   && vp[DIR_ZIPsFS_L]=='/' && STARTSWITH(vp,DIR_ZIPsFS))
#define IS_IN_DIR_AUTOGEN(vp,vp_l) (vp_l >DIR_AUTOGEN_L+1 && vp[DIR_ZIPsFS_L]=='/' &&  vp[DIR_AUTOGEN_L]=='/' && STARTSWITH(vp,DIR_AUTOGEN))
#define IS_DIR_AUTOGEN(vp,vp_l)    (vp_l==DIR_AUTOGEN_L   && vp[DIR_ZIPsFS_L]=='/' && !memcmp(vp,DIR_AUTOGEN,DIR_AUTOGEN_L))




enum enum_autogen_state{AUTOGEN_UNINITILIZED,AUTOGEN_SUCCESS,AUTOGEN_FAIL};
///////////////////////////////////////
/// Enums and corresponding strings ///
///////////////////////////////////////
#define A1() C(HT_MALLOC_UNDEFINED)C(HT_MALLOC_warnings)C(HT_MALLOC_ht_count_getattr)C(HT_MALLOC_file_ext)C(HT_MALLOC_inodes)C(HT_MALLOC_transient_cache)C(HT_MALLOC_without_dups)C(HT_MALLOC_LEN)
#define A3() C(WARN_INIT)C(WARN_MISC)C(WARN_CONFIG)C(WARN_STR)C(WARN_INODE)C(WARN_THREAD)C(WARN_MALLOC)C(WARN_ROOT)C(WARN_OPEN)C(WARN_READ)C(WARN_ZIP_FREAD)C(WARN_READDIR)C(WARN_SEEK)C(WARN_ZIP)C(WARN_GETATTR)C(WARN_STAT)C(WARN_FHANDLE)C(WARN_DIRCACHE)C(WARN_MEMCACHE)C(WARN_FORMAT)C(WARN_DEBUG)C(WARN_CHARS)C(WARN_RETRY)C(WARN_AUTOGEN)C(WARN_C)C(WARN_NET)C(WARN_LEN)
#define A4(x) C(memcache_status_nil)C(memcache_queued)C(memcache_reading)C(memcache_done)C(MEMCACHE_STATUS_NUM)
#define A5() C(MEMCACHE_NEVER)C(MEMCACHE_SEEK)C(MEMCACHE_RULE)C(MEMCACHE_COMPRESSED)C(MEMCACHE_ALWAYS)
#define A7(x) C(PTHREAD_NIL)C(PTHREAD_ASYNC)C(PTHREAD_MEMCACHE)C(PTHREAD_MISC)C(PTHREAD_LEN)
#define A8(x) C(mutex_nil)C(mutex_fhandle)C(mutex_async)C(mutex_mutex_count)C(mutex_mstore_init)C(mutex_autogen_init)C(mutex_dircache_queue)C(mutex_log_count)C(mutex_crc)C(mutex_inode)C(mutex_memUsage)C(mutex_dircache)C(mutex_idx)C(mutex_validchars)C(mutex_special_file)C(mutex_validcharsdir)C(mutex_textbuffer_usage)C(mutex_roots)C(mutex_len) //* mutex_roots must be last */

#define A9(x) C(LOG_DEACTIVATE_ALL)C(LOG_FUSE_METHODS_ENTER)C(LOG_FUSE_METHODS_EXIT)C(LOG_ZIP)C(LOG_ZIP_INLINE)C(LOG_EVICT_FROM_CACHE)C(LOG_MEMCACHE)C(LOG_REALPATH)C(LOG_AUTOGEN)C(LOG_READ_BLOCK)\
       C(LOG_TRANSIENT_ZIPENTRY_CACHE)\
       C(LOG_STAT)C(LOG_OPEN)C(LOG_OPENDIR)\
       C(LOG_INFINITY_LOOP_RESPONSE)C(LOG_INFINITY_LOOP_STAT)C(LOG_INFINITY_LOOP_MEMCACHE)C(LOG_INFINITY_LOOP_DIRCACHE)C(LOG_INFINITY_LOOP_MISC)  C(LOG_FLAG_LENGTH)

#define A10(x) C(ASYNC_NIL)C(ASYNC_STAT)C(ASYNC_READDIR)C(ASYNC_OPENFILE)C(ASYNC_OPENZIP)C(ASYNC_MEMCACHE)C(ASYNC_LENGTH)


#define A12() C(COUNT_UNDEFINED) C(COUNT_MALLOC_TESTING)\
       C(COUNT_HT_MALLOC_TRANSIENT_CACHE)C(COUNT_MALLOC_KEY_TRANSIENT_CACHE)\
       C(COUNT_HT_MALLOC_MISMATCH)C(COUNT_HT_MALLOC_KEY_MISMATCH)\
       C(COUNT_HT_MALLOC_NODUPS)\
       C(COUNT_MSTORE_MMAP_BYTES_NODUPS) C(COUNT_MSTORE_MALLOC_NODUPS)\
       C(COUNT_MSTORE_MMAP_BYTES_MISMATCH)                    C(COUNT_MSTORE_MALLOC_MISMATCH)\
       C(COUNT_MSTORE_MMAP_BYTES_DIR_FILENAMES)                C(COUNT_MSTORE_MALLOC_DIR_FILENAMES)\
  C(COUNT_MSTORE_MMAP_BYTES_TRANSIENT_CACHE_VALUES)       C(COUNT_MSTORE_MALLOC_TRANSIENT_CACHE_VALUES)\
  C(COUNT_HT_MALLOC_KEY)\
  C(COUNT_AUTOGEN_MALLOC_replacements)\
  C(COUNT_AUTOGEN_MALLOC_argv)\
  C(COUNT_AUTOGEN_MALLOC_TXTBUF)\
  C(COUNT_TXTBUF_SEGMENT_MALLOC)\
  C(COUNT_TXTBUF_SEGMENT_MMAP_BYTES)\
  C(COUNT_MALLOC_dir_field)\
  C(COUNT_MALLOC_dircachejobs)\
  C(COUNT_MEMCACHE_MALLOC)\
  C(COUNT_MALLOC_MEMCACHE_TXTBUF)\
  C(COUNT_ZIP_OPEN)\
  C(COUNT_ZIP_FOPEN)\
  C(COUNT_FHANDLE_CONSTRUCT)\
  C(COUNT_FHANDLE_ARRAY_MALLOC_MISMATCH)\
  C(COUNT_FHANDLE_TRANSIENT_CACHE)\
       C(COUNT_PAIRS_END)\
\
       C(COUNT_MEMCACHE_WAITFOR_TIMEOUT)\
       C(COUNT_READZIP_MEMCACHE)\
       C(COUNT_READZIP_MEMCACHE_BECAUSE_SEEK_BWD)\
  C(COUNT_STAT_FROM_CACHE)\
       C(COUNT_PTHREAD_LOCK)\
  C(COUNT_SEQUENTIAL_INODE)\
  C(COUNT_NUM)


#define C(a) a,
enum enum_mstoreid{A1()};
enum enum_mallocid{A12()};
enum enum_warnings{A3()};
#if WITH_MEMCACHE
enum enum_memcache_status{A4()};
enum enum_when_memcache_zip{A5()};
#endif //WITH_MEMCACHE
enum enum_root_thread{A7()};
enum enum_mutex{A8()};
enum enum_log_flags{A9()};
enum enum_async{A10()};
#undef C
#define C(a) #a,
static const char *HT_MALLOC_S[]={A1()NULL};
static const char *COUNT_S[]={A12()NULL};
static const char *MY_WARNING_NAME[]={A3()NULL};
IF1(WITH_MEMCACHE,static const char *MEMCACHE_STATUS_S[]={A4()NULL});
IF1(WITH_MEMCACHE,static const char *WHEN_MEMCACHE_S[]={A5()NULL});
static const char *PTHREAD_S[]={A7()NULL};
static const char *MUTEX_S[]={A8()NULL};
static const char *LOG_FLAG_S[]={A9()NULL};
static const char *ASYNC_S[]={A10()NULL};
#undef C
#undef A1

#undef A3
#undef A4
#undef A5
//#undef A6
#undef A7
#undef A8
#undef A9
#undef A10

#undef A11
#undef A12
#undef A13


struct counter_rootdata{
  const char *ext;
  atomic_uint counts[counter_rootdata_num];
  long rank;
  clock_t wait;
};
typedef struct counter_rootdata counter_rootdata_t;


struct autogen_files;
// ---
#if ! WITH_DIRCACHE
#undef WITH_ZIPINLINE
#define WITH_ZIPINLINE 0
#undef WITH_ZIPENTRY_PLACEHOLDER
#define WITH_ZIPENTRY_PLACEHOLDER 0
#undef WITH_ZIPINLINE_CACHE
#define WITH_ZIPINLINE_CACHE 0
#endif
// ---
#if ! WITH_ZIPINLINE
#undef WITH_ZIPINLINE_CACHE
#define WITH_ZIPINLINE_CACHE 0
#endif
// ---
//#define C_FILE_DATA_WITHOUT_FINODE()    C(fsize,off_t); C(fmtime,uint64_t); C(fcrc,uint32_t); C(fflags,uint8_t); C(fname,char *);
#define C_FILE_DATA_WITHOUT_NAME()    C(fsize,off_t);  C(fmtime,uint64_t); C(fcrc,uint32_t); C(fflags,uint8_t); C(finode,uint64_t);
#define C_FILE_DATA()    C(fname,char *); C_FILE_DATA_WITHOUT_NAME();
#define C(field,type) type *field;
struct directory_core{
  struct timespec dir_mtim;
  int files_l;
  C_FILE_DATA();
};
#undef C










// ---
////////////////
/// zippath  ///
////////////////
struct zippath{
#define C(s) int s,s##_l
  char strgs[ZPATH_STRGS];  int strgs_l; /* Contains all strings: virtualpath virtualpath_without_entry, entry_path and finally realpath */
  C(virtualpath); /* The path in the FUSE fs relative to the mount point */
  C(virtualpath_without_entry);  /*  Let Virtualpath be "/foo.zip.Content/bar". virtualpath_without_entry will be "/foo.zip.Content". */
  C(entry_path); /* Let Virtualpath be "/foo.zip.Content/bar". entry_path will be "bar". */
  C(realpath); /* The physical path of the file. In case of a ZIP entry, the path of the ZIP-file */
#undef C
  ht_hash_t virtualpath_hash,virtualpath_without_entry_hash,realpath_hash;
  zip_uint32_t zipcrc32;
  struct rootdata *root;
  int current_string; /* The String that is currently build within strgs with zpath_newstr().  With zpath_commit() this marks the end of String. */
  struct stat stat_rp,stat_vp;
  uint32_t flags;
};


struct async_zipfile{
  zip_file_t *zf;
  struct zip *za;
  struct zippath azf_zpath;
} static const async_zipfile_empty;


#define DIRECTORY_DIM_STACK IF01(WITH_TESTING_REALLOC,4,MAX(256,ULIMIT_S))
struct directory{
  STRUCT_NOT_ASSIGNABLE();
  struct zippath dir_zpath;
#define DIR_RP(dir)      ((dir)->dir_zpath.strgs+(dir)->dir_zpath.realpath)
#define DIR_RP_L(dir)    ((dir)->dir_zpath.realpath_l)
#define DIR_VP(dir)      ((dir)->dir_zpath.strgs+(dir)->dir_zpath.virtualpath)
#define DIR_VP_L(dir)    ((dir)->dir_zpath.virtualpath_l)
#define DIR_ROOT(dir)    ((dir)->dir_zpath.root)
#define DIR_IS_ZIP(dir) (((dir)->dir_zpath.flags&ZP_ZIP)!=0)
#define C(field,type) type _stack_##field[DIRECTORY_DIM_STACK];
  C_FILE_DATA();
#undef C
  struct directory_core core; // Only this data goes to dircache.
  struct mstore filenames;
  int files_capacity,cached_vp_to_zip;
  bool debug, dir_is_dircache, dir_is_destroyed, dir_is_success;
  /* The following concern asynchronized reading */
  bool async_never;
};

#define ROOT_WHEN_SUCCESS(r,t) atomic_load(r->thread_when_success+t)
#define ROOT_SUCCESS_SECONDS_AGO(r) (time(NULL)-ROOT_WHEN_SUCCESS(r,PTHREAD_ASYNC))
#define ROOT_NOT_RESPONDING(r)  (r->remote && ROOT_SUCCESS_SECONDS_AGO(r)>ROOT_RESPONSE_WITHIN_SECONDS)


#define ZP_STARTS_AUTOGEN (1<<2)
#define ZP_ZIP            (1<<3)
#define ZP_DOES_NOT_EXIST (1<<4)
#define ZP_IS_COMPRESSED  (1<<5)



#define ZPATH_IS_ZIP() ((zpath->flags&ZP_ZIP)!=0)
#define ZPATH_ROOT_WRITABLE() (zpath->root && 0!=(zpath->root->writable))
#define LOG_FILE_STAT() cg_log_file_stat(zpath->realpath,&zpath->stat_rp),log_file_stat(zpath->virtualpath,&zpath->stat_vp)
#define VP() (zpath->strgs+zpath->virtualpath)
#define EP() (zpath->strgs+zpath->entry_path)
#define EP_L() zpath->entry_path_l
#define VP_L() zpath->virtualpath_l
#define ZP_RP(zpath) ((zpath)->strgs+(zpath)->realpath)
#define RP() ZP_RP(zpath)
#define RP_L() (zpath->realpath_l)
#define VP0() (zpath->strgs+zpath->virtualpath_without_entry)
#define VP0_L() zpath->virtualpath_without_entry_l
#define D_VP(d) (d->zpath.strgs+d->zpath.virtualpath)
#define D_VP0(d) (d->zpath.strgs+d->zpath.virtualpath_without_entry)
#define D_VP0(d) (d->zpath.strgs+d->zpath.virtualpath_without_entry)
#define D_VP_HASH(d) d->zpath.virtualpath_hash
#define D_EP(d) (d->zpath.strgs+d->zpath.entry_path)
#define D_EP_L(d) d->zpath.entry_path_l
#define D_VP_L(d) d->zpath.virtualpath_l
#define D_RP(d) (d->zpath.strgs+d->zpath.realpath)
#define D_RP_HASH(d) (d->zpath.realpath_hash)
#define D_RP_L(d) (d->zpath.realpath_l)
#define NEW_ZIPPATH(virtpath)  struct zippath __zp={0},*zpath=&__zp;zpath_init(zpath,virtpath)
#define FIND_REALPATH(virtpath)    NEW_ZIPPATH(virtpath);  found=find_realpath_any_root(0,zpath,NULL);
////////////////////////////////////////////////////////////////////////////////////////////////////
///   The struct fHandle "file handle" holds data associated with a file descriptor.
///   They are stored in the linear list _fhandle. The list may have holes.
///   Memcache: It may also contain the cached file content of the zip entry.
///   Only one of all instances with a specific virtual path should store the cached zip entry
////////////////////////////////////////////////////////////////////////////////////////////////////




#define FINDRP_AUTOGEN_CUT (1<<1)
#define FINDRP_AUTOGEN_CUT_NOT (1<<2)
#define FINDRP_NOT_TRANSIENT_CACHE (1<<3)
#define FILETYPEDATA_NUM 1024
#define FILETYPEDATA_FREQUENT_NUM 64
// #define foreach_fhandle_also_emty(id,d) int id=_fhandle_n;for(struct fHandle *d;--id>=0 && ((d=fhandle_at_index(id))||true);)

#define foreach_fhandle_also_emty(id,d) struct fHandle *d; for(int id=_fhandle_n;--id>=0 && ((d=fhandle_at_index(id))||true);)
#define fhandle_virtualpath_equals(d,e) (d!=e && D_VP_HASH(e)==D_VP_HASH(d) && !strcmp(D_VP(d),D_VP(e)))
#define fhandle_zip_ftell(d) d->zip_fread_position
// cppcheck-suppress-macro constVariablePointer
#define foreach_fhandle(id,d)  foreach_fhandle_also_emty(id,d) if (d->flags)




/* flags for config_file_attribute_valid_seconds() */
#define STAT_CACHE_FILE_IS_READONLY (1<<2)
#define STAT_CACHE_ROOT_IS_REMOTE   (1<<3)
#define STAT_CACHE_ROOT_IS_WRITABLE (1<<4)

#define FHANDLE_LOG2_BLOCK_SIZE 5
#define FHANDLE_BLOCKS 512
#define FHANDLE_BLOCK_SIZE (1<<FHANDLE_LOG2_BLOCK_SIZE)
#define FHANDLE_MAX (FHANDLE_BLOCKS*FHANDLE_BLOCK_SIZE)

struct fHandle{
  uint64_t fh, fh_real;
  struct zip *zip_archive;
  zip_file_t *zip_file;
  struct zippath zpath;
  volatile time_t accesstime;
  volatile int flags;
#define FHANDLE_FLAG_ACTIVE                         (1<<0)
#define FHANDLE_FLAG_DESTROY_LATER                  (1<<1)
#define FHANDLE_FLAG_OPEN_LATER_IN_READ_OR_WRITE    (1<<2)
#define FHANDLE_FLAG_SEEK_FW_FAIL                   (1<<3)
#define FHANDLE_FLAG_SEEK_BW_FAIL                   (1<<4)
#define FHANDLE_FLAG_WITH_TRANSIENT_ZIPENTRY_CACHES (1<<5) /* Can attach ht_transient_cache */
#define FHANDLE_FLAG_IS_AUTOGEN                     (1<<6)
#define FHANDLE_FLAG_WITH_MEMCACHE                  (1<<8)
#define FHANDLE_FLAG_WITHOUT_MEMCACHE               (1<<9)
#define FHANDLE_FLAG_MEMCACHE_COMPLETE              (1<<10)
#define FHANDLE_FLAG_SPECIAL_FILE                   (1<<11)
#define FHANDLE_FLAG_IS_CCODE                       (1<<12)
  //#define FHANDLE_FLAG_NOT_CCODE                      (1<<13)
  uint8_t already_logged;
  volatile int64_t offset,n_read;
  volatile atomic_int is_busy; /* Increases when entering xmp_read. If greater 0 then the instance must not be destroyed. */
  pthread_mutex_t mutex_read; /* Costs 40 Bytes */
  counter_rootdata_t *filetypedata;
  off_t zip_fread_position;
  IF1(WITH_TRANSIENT_ZIPENTRY_CACHES,struct ht *ht_transient_cache);
  IF1(WITH_MEMCACHE, struct memcache * volatile memcache; atomic_int volatile is_memcache_store);
  IF1(WITH_AUTOGEN,enum enum_autogen_state autogen_state; int autogen_error);
} static const FHANDLE_EMPTY;

/////////////////////////////////////////////////////////////////////////
///  Union file system:
///  struct rootdata holds the data for a branch
///  This is the root path  of an upstream source file tree.
///  ZIPsFS is a union file system and combines all source directories
//////////////////////////////////////////////////////////////////////////
#define foreach_root(r)    for(struct rootdata *r=_root; r<_root+_root_n; r++)
struct rootdata{
  char rootpath[MAX_PATHLEN+1];
  char retain_dirname[MAX_PATHLEN+1]; /* last path component with a leading slash without trailing slash   or "" */
  int rootpath_l,retain_dirname_l;
  struct statvfs statvfs;
  uint32_t log_count_delayed,log_count_delayed_periods,log_count_restarted;
  struct ht dircache_queue,dircache_ht,ht_inodes; // !!
#if WITH_DIRCACHE || WITH_STAT_CACHE
  struct ht dircache_ht_fname, dircache_ht_fnamearray;
  struct mstore dircache_mstore;
#endif
  struct ht ht_filetypedata;
  pthread_t thread[PTHREAD_LEN];
  int thread_count_started[PTHREAD_LEN];
  int thread_when_canceled[PTHREAD_LEN];
  bool thread_pretend_blocked[PTHREAD_LEN];
  atomic_int thread_starting[PTHREAD_LEN];
  bool thread_is_run[PTHREAD_LEN];
  pid_t thread_pid[PTHREAD_LEN];
  counter_rootdata_t filetypedata_dummy,filetypedata_all, filetypedata[FILETYPEDATA_NUM],filetypedata_frequent[FILETYPEDATA_FREQUENT_NUM];
  bool filetypedata_initialized, blocked, writable, remote;
  int seq_fsid;
  unsigned long f_fsid; /* From statvfs.f_fsid */
  pthread_mutex_t async_mtx[ASYNC_LENGTH];
  atomic_int async_go[ASYNC_LENGTH];
  int async_task_id[ASYNC_LENGTH];
  volatile atomic_ulong async_when_success[ASYNC_LENGTH],async_when[ASYNC_LENGTH],thread_when_success[PTHREAD_LEN]; _Static_assert(sizeof(atomic_ulong)>=sizeof(time_t),"");
  IF1(WITH_TIMEOUT_OPENFILE,int  async_openfile_fd,async_openfile_flags;  char async_openfile_path[MAX_PATHLEN+1]);
  IF1(WITH_TIMEOUT_STAT,    struct stat async_stat;  struct strg async_stat_path);
  IF1(WITH_TIMEOUT_READDIR, struct directory *async_dir);
  IF1(WITH_TIMEOUT_OPENZIP, struct async_zipfile *async_zipfile);
};



///////////////
/// Logging ///
///////////////
#define IF_LOG_FLAG_OR(f,or) if (f && _log_flags&(1<<f)||or)
#define IF_LOG_FLAG(f) if (f && _log_flags&(1<<f))
#define LOG_FUSE(path)          IF_LOG_FLAG(LOG_FUSE_METHODS_ENTER)log_entered_function("%s",path)
#define LOG_FUSE_RES(path,res)  IF_LOG_FLAG(LOG_FUSE_METHODS_ENTER)log_entered_function("%s res:%d",path,res)
//
#define ADVISE_DIRCACHE_IS_ZIP              (1<<1)
#define ADVISE_DIRCACHE_IS_REMOTE           (1<<2)
//
#define ADVISE_CACHE_IS_CMPRESSED           (1<<1) /* This  ZIP entry is compressed. */
#define ADVISE_CACHE_IS_SEEK_BW             (1<<2) /* There is currently an atempt to seek backward. This is inefficient for compressed ZIP entries. */
#define ADVISE_CACHE_BY_POLICY              (1<<3)
#define ADVISE_CACHE_IS_ZIPENTRY            (1<<4)
//
#if WITH_MEMCACHE
struct memcache{
  volatile enum enum_memcache_status memcache_status;
  struct textbuffer *txtbuf;
  struct zippath m_zpath; /* To try find_realpath_other_root() */
  volatile off_t memcache_l,memcache_already;
  int64_t memcache_took_mseconds, memcache_took_mseconds_in_lock;
  int id;
};
#endif // WITH_MEMCACHE

////////////////////
/// Directories  ///
////////////////////
#define FILLDIR_AUTOGEN (1<<0)
#define FILLDIR_IS_DIR_ZIPsFS (1<<1)
#define FILLDIR_STRIP_NET_HEADER (1<<2)
#define  directory_update_time(success,dir)  root_update_time(ASYNC_READDIR,success,DIR_ROOT(dir))
#define filler_add_no_dups(filler,buf,name,st,no_dups) {if (ht_only_once(no_dups,name,0)) filler(buf,name,st,0 COMMA_FILL_DIR_PLUS);}
