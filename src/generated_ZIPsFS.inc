static void destroy_thread_data(void *x);
static int cg_mutex_count(int mutex,int inc);
static MAYBE_INLINE void lock(int mutex);
static MAYBE_INLINE void unlock(int mutex);
static void cg_mutex_challenge_1(void);
static void cg_mutex_challenge_2(void);
static char *path_of_this_executable(void);
static void provoke_idx_out_of_bounds(void);
static void enable_core_dumps(void);
static bool filepath_contains_blocking(const char *p);
static bool tdf_or_tdf_bin(const char *p);
static bool filename_starts_year(const char *p,int l);
static bool file_starts_year_ends_dot_d(const char *p);
static bool _report_failure_for_tdf(const char *mthd, int line, const char *path);
static void assert_dir(const char *p, const struct stat *st);
static void assert_r_ok(const char *p, const struct stat *st);
static const char *function_name(enum enum_functions f);
static void _log_count_b(enum enum_functions f);
static void _log_count_e(enum enum_functions f,const char *path);
static void func3(void);
static void cg_print_stacktrace_using_debugger(void);
static const char *this_executable(void);
static bool addr2line_output(FILE *f,const char *line,int i);
static bool addr2line_no_shell(const char *addr,const int iLine);
static bool addr2line(const char *addr, int lineNb);
static void cg_print_stacktrace(int calledFromSigInt);
static void _cg_print_stacktrace_test1(void);
static void _cg_print_stacktrace_test2(void);
static void cg_print_stacktrace_test(int what);
static void my_signal_handler(int sig);
static void init_sighandler(const char* main_argv_0, uint64_t signals,FILE *out);
static void function_a(void);
static bool cg_uid_is_developer();
static void *malloc_untracked(const size_t size);
static void *calloc_untracked(const size_t nmemb,const size_t size);
static char *strdup_untracked(const char *s);
static bool has_proc_fs(void);
static void puts_stderr(const char *s);
static const char *cg_error_symbol(const int x);
static const char *error_symbol_zip(const int x);
static void fprint_strerror(FILE *f,int err);
static void *cg_malloc(const int id, const size_t size);
static void *cg_calloc(const int id,size_t nmemb, size_t size);
static char *cg_strdup(const int id,const char *s);
static void cg_free(const int id,const void *ptr);
static void *_cg_realloc_array(const int id,const int size1AndOpt,const void *pOld, const size_t nOld, const size_t nNew);
static void *_cg_mmap(const int id, const off_t length, const int fd_or_zero, const char *file, const int line);
static int _cg_munmap(const int id,const void *ptr,const off_t length);
static int cg_last_nospace_char(const char *s);
static char cg_last_char(const char *s);
static char* cg_strrchr_null(const char *path, const char c);
static int cg_count_chr(const char *str, const char c);
static uint32_t hash32(const char* key, const uint32_t len);
static uint64_t hash64(const char* key, const off_t len);
static int cg_str_str(const char *s,const char *substr);
static const char *cg_str_lremove(const char *s, const char *pfx,const int  pfx_l);
static int cg_empty_dot_dotdot(const char *s);
static char *_cg_strncpy(const bool stpcpy,char *dst,const char *src,const int num);
static uint32_t cg_strlen(const char *s);
static int cg_sum_strlen(const char **ss, const int n);
static int cg_idx_of_pointer(void **aa, const int n, const void *a);
static bool cg_endsWith(const int flags, const char* s,int s_l,const char* e,int e_l);
static bool cg_startsWith(const char* s,int s_l,const char* e,int e_l);
static bool cg_endsWithZip(const char *s, const int len_or_0);
static bool cg_isURL(const char *url);
static bool cg_endsWithDotD(const char *s, int len);
static int cg_find_suffix(const int opt,const char *s, const int s_l,const char **xx,const int *xx_l);
static int cg_last_slash_l(const char *path,const int path_l );
static int cg_leading_slashes(const char *s);
static bool cg_starts_digits_char(const char *s,const int nDigit, const int c);
static int cg_str_replace(const int opt,char *haystack, const int h_l_or_zero, const char *needle,  const int n_l_or_zero, const char *replacement,  const int r_l_or_zero);
static int cg_strsplit(int opt_and_sep, const char *s, const int s_l, const char *tokens[], int *tokens_l);
static int cg_str_join(char *tmp, const int soft_max, const int hard_max, const char **ss, const char *sep);
static const char *rm_pfx_us(const char *s);
static int64_t currentTimeMillis(void);
static void _cg_sleep_ms(const int millisec, const char *msg, const char *func,const int line);
static void cg_nanosleep(long nanos);
static void cg_usleep(int usec);
static int cg_pathlen_ignore_trailing_slash(const char *p);
static bool cg_path_equals_or_is_parent(const char *subpath,const int subpath_l,const char *path,const int path_l);
static bool *cg_validchars(enum enum_validchars type);
static int cg_find_invalidchar(enum enum_validchars type,const char *s,const int len);
static int url_encode(char *dst, const int dst_l, const char *name);
static char * _cg_path_for_fd(const char *func, const int line, char *path, const int fd);
static int cg_count_fd_this_prg(void);
static bool cg_check_path_for_fd(const char *title, const char *path, int fd);
static void cg_print_path_for_fd(int fd);
static void cg_array_remove_element(const char *aa[],const void *element);
static int cg_array_length(const char **xx);
static int isPowerOfTwo(unsigned int n);
static unsigned int isqrt(unsigned int y);
static bool is_square_number(unsigned int y);
static long closest_with_identical_digits(const long num);
static MAYBE_INLINE int64_t cg_atol_kmgt(const char *s);
static void cg_log_file_mode(mode_t m);
static long cg_file_size(const char *path);
static bool cg_file_exists(const char *path);
static void stat_init(struct stat *st, int64_t size,const struct stat *uid_gid);
static bool cg_stat_parent_and_file(const char *parent, const int parent_l, const char *n, const int n_l, struct stat *st);
static void _cg_log_file_stat(const char *func,const char * name,const struct stat *s);
static void cg_log_open_flags(int flags);
static bool cg_stat_differ(const char *title,const struct stat *s1,const struct stat *s2);
static bool cg_is_stat_mode(const mode_t mode,const char *f);
static bool cg_file_set_atime(const char *path, const struct stat *st_or_null,long secondsFuture);
static bool cg_file_set_mtimes(const char *path, const struct timespec mtime);
static bool cg_file_set_mtime(const char *path, const time_t time);
static bool cg_set_st_mode_flag(const char *path, mode_t mode);
static int cg_getc_tty(void);
static bool cg_fd_write(const int fd,const char *t,const off_t size0);
static bool cg_fd_write_str(const int fd,const char *t);
static ssize_t cg_copy_file_content_fd(const int i, const int o);
static ssize_t cg_copy_file_content(const char *infile, const char *outfile);
static int cg_rename(const char *old, const char *n);
static bool cg_unlink(const char *f);
static int cg_vmtouch_e(const char *f);
static int cg_symlink_overwrite_atomically(const char *src,const char *lnk);
static bool cg_mkdir(const char *path,const mode_t mode);
static bool _cg_recursive_mkdir(const bool parentOnly,const char *path);
static void log_list_filedescriptors(const int fd);
static char* cg_path_expand_tilde(char *dst, const int dst_max, const char *path);
static void _tmp_for_file(char tmp[], const char *f);
static bool cg_rename_tmp_outfile(const char *tmp, const char *f);
static double cg_timespec_diff(const struct timespec a, const struct timespec b);
static struct timespec cg_file_last_modified(const char *path);
static bool cg_file_is_newer_than(const char *path1,const char *path2);
static struct timespec cg_file_mtim(const char *path);
static time_t cg_file_mtime(const char *path);
static char *cg_ctime(time_t t);
static bool cg_is_member_of_group(char *group);
static bool cg_is_member_of_group_docker(void);
static bool cg_log_exec_fd(const int fd, const char *cmd[], const char  *env[]);
static bool cg_log_waitpid_status(FILE *f,const unsigned int status,const char *msg);
static int _cg_log_waitpid(const int pid, const int status, const char *err,const bool append, const char  *cmd[], const char *env[], const char *func);
static int fd_dev_null();
static int cg_exec(const char *cmd[], const char *env[],const int fd_in,const int fd_out,const int fd_err);
static bool cg_fork_exec(const char *cmd[], const char *env[],const int fd_in,const int fd_out,const int fd_err);
static bool is_installed_program(const char *prg);
static char *cg_compression_file_ext(const int i,int *ext_l);
static int cg_compression_for_filename(const char *s, const int len_or_0);
static bool cg_cmd_decompress(const int i,const char **cmd, const char *src);
static bool cg_pid_exists_proc(const pid_t pid);
static long cg_read_gzip(const int in, const int out, void (*progress)(void*), void *progress_para);
static bool cg_exec_pipe(const char  *cmd1[], const char  *env[], const char *cmd2[], const int fdout,  void (*progress)(void*), void *progress_para);
static int cg_read_file_into_buffer(char *buf, const int buf_l, const char *path);
static long cg_read_fd(const int in, const int out,void (*progress)(void*), void *progress_para);
static bool cg_download_url(const int opt_and_compress, const char *url, const char *outfile, void (*progress)(void*), void *progress_para);
static bool cg_copy_url_or_file(const int iCompress,const char *src_path_without_ext, const char *dst, void (*progress)(void*), void *progress_para);
static void sleep_exit();
static int cg_unicode(char *s, const int c,const bool html);
static void ht_set_mutex(const int mutex,ht_t *ht);
static ht_entry_t*  _ht_malloc_entries(const uint32_t n);
static ht_t *_ht_init_with_keystore(ht_t *ht,const char *name,uint32_t flags_log2initalCapacity, struct mstore *m, uint32_t mstore_dim);
static void _ht_free_entries(ht_t *ht);
static void ht_destroy(ht_t *ht);
static void ht_clear(ht_t *ht);
static MAYBE_INLINE int debug_count_empty(const ht_entry_t *ee, const uint32_t capacity);
static ht_entry_t* _ht_get_entry_ee(ht_entry_t *ee, const uint32_t capacity, const bool intkey,const char* key, const ht_keylen_hash_t keylen_hash);
static int _ht_expand(ht_t *ht);
static const char* _newKey(ht_t *ht,const char *key,ht_keylen_hash_t keylen_hash);
static ht_entry_t *ht_get_entry(ht_t *ht, const char* key,const ht_keylen_t key_l,ht_hash_t hash,const bool create);
static void ht_clear_entry(const ht_t *ht,ht_entry_t *e);
static ht_entry_t* ht_remove(ht_t *ht,const char* key,const ht_keylen_t key_l, ht_hash_t hash );
static void *ht_set(ht_t *ht,const char* key,const ht_keylen_t key_l,ht_hash_t hash, const void* value);
static void* ht_get(const ht_t *ht, const char* key,const ht_keylen_t key_l,const ht_hash_t hash);
static const void *ht_intern(ht_t *ht,const void *bytes,const off_t bytes_l,ht_hash_t hash,const int memoryalign);
static bool ht_only_once(ht_t *ht,const char *s,const int s_l_or_zero);
static void* ht_sget(const ht_t *ht, const char* key);
static ht_entry_t* ht_sget_entry(ht_t *ht, const char* key,const bool create);
static void *ht_sset(ht_t *ht,const char* key, const void* value);
static const void *ht_sinternalize(ht_t *ht,const char *key);
static ht_entry_t *ht_numkey_get_entry(ht_t *ht, ht_keylen_hash_t key_high_variability, uint64_t const key2,bool create);
static void *ht_numkey_set(ht_t *ht, ht_keylen_hash_t key_high_variability, const uint64_t key2, const void *value);
static int ht_report_memusage(int n,ht_t *ht,const bool html);
static void ht_debug_print_keys(const ht_t *ht);
static void test_ht_1(int argc, const char *argv[]);
static void test_num_keys(int argc, const char *argv[]);
static void test_internalize(int argc, const char *argv[]);
static void test_intern_num(int argc, const char *argv[]);
static void test_use_as_set(int argc, const char *argv[]);
static void test_unique(int argc, const char *argv[]);
static  void test_no_dups(int argc,const char *argv[]);
static void test_mstore2(int argc, const char *argv[]);
static void test_intern_substring(int argc, const char *argv[]);
static void _warning(const char *fn,int line,const uint32_t channel,const char* path,const char *format,...);
static int cpuusage_read_proc(struct pstat* r,const pid_t pid);
static void cpuusage_calc_pct(const struct pstat* cur_usage,const struct pstat* last_usage,float* ucpu_usage, float* scpu_usage);
static void cpuusage_calc(const struct pstat* cur_usage,const struct pstat* last_usage,long unsigned int* ucpu_usage,long unsigned int* scpu_usage);
static textbuffer_t *textbuffer_new(const int malloc_id);
static off_t textbuffer_length(const textbuffer_t *b);
static int textbuffer_char_at(const textbuffer_t *b, const off_t pos);
static off_t _textbuffer_copy_to_or_compare(const bool isCopy,const textbuffer_t *b,const off_t from,const off_t to, char *dst);
static void *malloc_or_mmap(const int flags, const off_t size);
static void _free_or_munmap(const int flags,const void *p,const off_t size);
static bool _textbuffer_assert_capacity(textbuffer_t *b,const int n);
static int textbuffer_add_segment(const uint8_t flags,textbuffer_t *b, const char *bytes, const off_t size_or_zero);
static char *textbuffer_malloc(const int flags,textbuffer_t *b, off_t size);
static off_t textbuffer_read(const uint8_t flags,textbuffer_t *b,const int fd);
static int textbuffer_from_exec_output(const uint8_t flags,textbuffer_t *b, const char *cmd[],const char *env[], const char *path_stderr);
static void textbuffer_reset(textbuffer_t *b);
static char *textbuffer_first_segment_with_min_capacity(const int flags,textbuffer_t *b, off_t min_size);
static void textbuffer_destroy(textbuffer_t *b);
static bool textbuffer_write_fd(textbuffer_t *b,const int fd);
static bool textbuffer_write_file(textbuffer_t *b,const char *path,const int mode);
static int textbuffer_differs_from_filecontent_fd(const textbuffer_t *b,const int fd);
static int exec_on_file(const int opts,const enum enum_exec_on_file type, char *output, const int output_max, const char *path );
static void test_ps_pid(const int pid);
static void test_write_byte_by_byte(const textbuffer_t *b);
static void test_write_bytes_block(const int fd,const textbuffer_t *b);
static void test_exec(void);
static void _argc_n(const int n, const int argc);
static void _test_write_file(int argc,  char *argv[]);
static int c_from_exec_output(textbuffer_t **bb,const uint8_t flags,const char *cmd[],const char *env[]);
static textbuffer_t *_zipsfs_c_init_tb(textbuffer_t **bb);
static bool c_getattr(struct stat *st, const virtualpath_t *vipa);
static bool c_file_content_to_fhandle(fHandle_t *d);
static bool c_readdir(const zpath_t *zpath,void *buf, fuse_fill_dir_t filler,ht_t *no_dups);
static int net_internet_file_colon(const char *vp,const int vp_l);
static void net_url_for_file(char *url, const char *vp,const int vp_l, const char *ext);
static bool net_header_download(const char *rph, const bool overwrite,const char *vp,const int vp_l,const char *ext);
static bool net_maybe_download(zpath_t *zpath);
static bool net_getattr(struct stat *st, const virtualpath_t *vipa);
static bool net_parse_header(struct stat *st,const char *rp,const int iCompress);
static time_t parse_http_time(const char *s);
static bool _isZipIC(const char *s);
static bool _isZip(const char *s);
static bool _is_tdf_or_tdf_bin(const char *path);
static const int config_virtual_dirpath_to_zipfile(const char *b, const char *e,char *append[]);
static uint64_t config_file_attribute_valid_seconds(const int opt, const char *path,const int path_l, const struct stat *st_or_null);
static bool config_zipfilename_to_virtual_dirname(char *dirname,const char *zipfile,const int zipfile_l);
static bool config_skip_zipfile_show_zipentries_instead(const char *zipfile,const int zipfile_l);
static bool config_not_report_stat_error(const char *path,const int path_l);
static off_t config_advise_preload_file_ram(const int flags,const char *virtualpath, const int vp_l, const char *realpath,const int rp_l,const char *rootpath,const off_t filesize);
static bool config_advise_evict_from_filecache(const char *realpath,const int realpath_l, const char *zipentryOrNull, const off_t filesize);
static bool config_advise_transient_cache_for_zipentries(const char *path, const int path_l);
static bool config_do_not_list_file(const char *parent, const char *filename,const int filename_l);
static bool config_not_overwrite(const char *path,const int path_l);
static bool config_advise_cache_directory_listing(const int flags,const char *path,const int path_l,const struct timespec mtime);
static char *config_some_file_path_extensions(const char *path, int path_l, int *return_index);
static long config_search_file_which_roots(const char *virtualpath,const int virtualpath_l);
static bool config_readir_no_other_roots(const char *realpath,const int realpath_l);
static bool config_file_is_readonly(const char *path, const int path_l);
static void config_exclude_files(const char *path, const int path_l, const int num_files, char **files, const off_t *fsize);
static bool config_has_sufficient_storage_space(const char *realpath, const long availableBytes, const long totalBytes);
static bool config_internet_update_header(const char *url, const struct stat *st);
static bool config_internet_hardlink_with_date_in_filename(const char *url);
static int config_internet_try_compressed(const char *vp,const int vp_l);
static bool config_allow_expand_symlink(const char *orig, const char *expanded);
static int countFhandleWithPreloadram(const char *path, int len,int h);
static void _fhandleWithPreloadramPrint(const char *func,int line,const char *path, int len,int h);
static bool _debugSpecificPath(int mode, const char *path, int path_l);
static void _assert_validchars(enum enum_validchars t,const char *s,int s_l,const char *fn);
static void _assert_validchars_direntries(const directory_t *dir,const char *fn);
static void _directory_print(const char *func,const int line,const directory_t *dir,const int maxNum);
static bool debug_path(const char *vp);
static bool debug_fhandle(const fHandle_t *d);
static void debug_fhandle_listall(void);
static void debug_compare_directory_a_b(directory_t *A,directory_t *B);
static void debug_track_false_getattr_errors(const char *vp,const int vp_l);
static bool debug_trigger_vp(const char *vp,const int vp_l);
static bool _stat_from_cache(const int opt_filldir_findrp,struct stat *stbuf, const char *rp, const root_t *r);
static bool stat_from_cache(const int opt_filldir_findrp,struct stat *st, const char *rp,  root_t *r);
static void stat_to_cache(const int opt_filldir_findrp,const struct stat *stbuf, const char *rp,  const int rp_l, root_t *r, time_t time_or_null);
static int dir_entry_to_stat_cache(const char *rp, const int rp_l, root_t *r);
static void dir_entries_to_stat_cache(directory_t *dir,root_t *r);
static void dircache_clear_if_reached_limit_all(const bool always,const int mask);
static bool _clear_ht(ht_t *ht);
static void dircache_clear_if_reached_limit(const bool always,const int mask,root_t *r,const off_t limit);
static void debug_assert_crc32_not_null(const directory_t *dir);
static void dircache_directory_to_cache(directory_t *dir);
static bool dircache_directory_from_cache(directory_t *dir);
static void maybe_evict_from_filecache(const int fdOrZero,const char *realpath,const int realpath_l, const char *zipentry, const int zipentry_l);
static bool zpath_has_inode(zpath_t *zpath);
static ht_t* transient_cache_make_ht(fHandle_t *d);
static zpath_t *transient_cache_get_or_create_zpath(const bool create,const bool must_be_same_zip, const char *virtualpath,const int virtualpath_l);
static int transient_cache_find_realpath(zpath_t *zpath);
static void transient_cache_store(const zpath_t *zpath, const char *vp,const int vp_l);
static void transient_cache_destroy(fHandle_t *d);
static void transient_cache_activate(fHandle_t *d);
static bool _preloaddisk_now(const char *dst,zpath_t *zpath,fHandle_t *d);
static bool preloaddisk_now(const char *dst,zpath_t *zpath,fHandle_t *d);
static fHandle_t *preloaddisk_fhandle(const fHandle_t *d);
static bool is_preloaddisk_zpath(const zpath_t *zpath);
static int preloaddisk(fHandle_t *d);
static void zpath_copy_rp(zpath_t *zpath, const char *rp, const struct stat *st);
static bool path_with_gz_exists(zpath_t *zpath, const root_t *r);
static void preloaddisk_uptodate_or_update(fHandle_t *d);
static bool async_wait(const char *path, const time_t t,root_t *r,const int A);
static void async_wait_picked(root_t *r,const int A);
static bool directory_rp_stat(directory_t *dir);
static bool readdir_now(directory_t *dir);
static void directory_to_queue(const directory_t *dir);
static bool async_periodically_dircache(root_t *r);
static void async_zipfile_init(struct async_zipfile *zip,const zpath_t *zpath);
static void openzip_now(struct async_zipfile *zip);
static void closezip_now(struct async_zipfile *z);
static inline bool async_periodically_stat(root_t *r);
static bool async_stat(const int opt_filldir_findrp,const char *rp,const int rp_l,struct stat *st,root_t *r);
static inline bool async_periodically_openfile(root_t *r);
static int async_openfile(zpath_t *zpath,const int flags);
static inline bool async_periodically_openzip(root_t *r);
static void async_openzip(struct async_zipfile *zip);
static void directory_copy(directory_t *dst,const directory_t *src, root_t *r);
static inline bool async_periodically_readdir(root_t *r);
static bool readdir_async(directory_t *dir);
static void root_start_thread(root_t *r,const enum enum_root_thread t,const bool evenIfAlreadyStarted);
static void log_infinity_loop(const root_t *r, const enum enum_root_thread t);
static void root_update_time(root_t *r, int t);
static void *infloop_async(void *arg);
static void *_cleanup_files_runnable(void *arg);
static void *infloop_misc(void *arg);
static void root_loading_active(void *root);
static void *infloop_preloadfile(void *arg);
static void init_infloop(root_t *r, const enum enum_root_thread ithread);
static void unblock_periodically();
static void log_root_blocked(root_t *r,const bool blocked);
static bool wait_for_root_timeout(root_t *r);
static char *_info_sprint_address(const int n);
static int _info_sprint_max(const int n);
static int append_description(const char *title, const char *descr, char *describe, const int max);
static int info_table_description(int n,char *txt, const int txt_max, const int txt_l);
static bool isKnownExt(const char *path, int len);
static int info_counts_by_filetype_by_root(int n);
static int _counts_by_filetype_r(int n, root_t *r, const int *count_explain);
static long counter_getattr_rank(const ht_entry_t *e);
static int info_counts_by_filetype(int n);
static int info_print_fuse_argv(int n);
static int print_proc_status(int n,char *filter,int *val);
static void log_virtual_memory_size(void);
static int log_memusage_ht(int n,const bool html);
static int info_mutex_locks(int n,const bool html);
static int info_malloc(int n,const bool html);
static int info_print_open_files(int n, int *fd_count);
static int print_maps(int n);
static int info_print_CPU(int n);
static int info_print_memory(int n);
static int print_fhandle(int n,const char *title);
static int print_all_info(const int flags);
static bool make_info(const int flags);
static void info_fuse_process(void);
static const char *zip_fdopen_err(int err);
static void fhandle_log_cache(const fHandle_t *d);
static bool preloadram_set_maxbytes(const char *s);
static bool preloadram_set_policy(const char *a);
static bool statForVirtualpathAndRootpath(struct stat *st, const char *vp, const char *rootpath);
static bool preloadram_advise(zpath_t *zpath, const int additional_flags);
static void preloadram_wait_for_free_mem(const zpath_t *zpath);
static enum enum_preloadram_status preloadram_get_status(const fHandle_t *d);
static void preloadram_set_status(fHandle_t *d,enum enum_preloadram_status status);
static struct preloadram *preloadram_new(fHandle_t *d);
static bool preloadram_try_destroy(fHandle_t *d);
static void preloadram_infer_from_other_handle(fHandle_t *d);
static bool is_preloadram_shared_with_other(const fHandle_t *d);
static bool _is_preloadram(const fHandle_t *d, const root_t *r,const char *func,const int line);
static bool preloadram_can_break(const fHandle_t *d);
static off_t preloadram_read(char *buf,const fHandle_t *d,const off_t from,off_t to);
static off_t preloadram_wait_and_read(char *buf, const off_t size, const off_t offset,fHandle_t *d);
static bool fhandle_check_crc32(fHandle_t *d);
static bool preloadram_store_try(fHandle_t *d, struct async_zipfile *zip, root_t *r);
static void preloadram_now(fHandle_t *d, root_t *r);
static bool fhandle_set_text(fHandle_t *d, textbuffer_t *b);
static bool preloadram_wait(fHandle_t *d, const off_t min_fill);
static char *ctrl_file_end();
static bool trigger_files(const bool isGenerated,const char *path,const int path_l);
static void  _sf_src_hc(textbuffer_t *b, const enum enum_configuration_src  id,const char *hc);
static void sf_file_ref(textbuffer_t *b,const int depth, const char *fn);
static void sf_n_file_ref(textbuffer_t *b, const char *fn);
static void _sf_requires(textbuffer_t *b,const char *val,const char *name);
static void sf_requires_rw(textbuffer_t *b);
static void sf_file_item(textbuffer_t *b,const int depth, const char *fn, const char **after);
static void sf_cleanup(textbuffer_t *b,const int depth);
static void sf_update(textbuffer_t *b,const int depth);
static off_t special_file_size(const int i);
static bool special_file_set_stat(struct stat *st, const virtualpath_t *vipa);
static uint64_t special_file_file_content_to_fhandle(zpath_t *zpath,const int special_file_id);
static void special_file_content_to_file(const int id, const char *path);
static void special_file_content(textbuffer_t *b,const enum enum_special_files id);
static void _rootdata_counter_inc(counter_rootdata_t *c, enum enum_counter_rootdata f);
static void fhandle_counter_inc( fHandle_t* d, enum enum_counter_rootdata f);
static void rootdata_counter_inc(const char *path, enum enum_counter_rootdata f, root_t* r);
static void log_path(const char *f,const char *path);
static void _log_zpath(const char *fn,const int line,const char *msg, zpath_t *zpath);
static bool fhandle_not_yet_logged(unsigned int flag,fHandle_t *d);
static void suggest_help(void);
static void ZIPsFS_usage(void);
static void log_flags_update();
static void init_count_getattr(void);
static void inc_count_by_ext(const char *path,enum enum_count_getattr field);
static const char *fileExtensionForPath(const char *path,const int len);
static counter_rootdata_t *filetypedata_for_ext(const char *path,root_t *r);
static bool find_realpath_try_inline(zpath_t *zpath, const char *vp, root_t *r);
static yes_zero_no_t find_realpath_try_inline_rules(zpath_t *zpath,char *append, root_t *r);
static bool readdir_inline_from_cache(const int opt, const zpath_t *zpath, const char *u, void *buf, fuse_fill_dir_t filler,ht_t *no_dups);
static const char *zinline_cache_vpath_to_zippath(const char *vp,const int vp_l);
static yes_zero_no_t zipinline_find_realpath_any_root(zpath_t *zpath,const long which_roots);
static void to_cache_vpath_to_zippath(directory_t *dir);
static void zipinline_cache_drop_vp(const char *vp, const int vp_l);
static const char *zipentry_placeholder_insert(char *s,const char *u, directory_t *dir);
static int zipentry_placeholder_expand2(char *n,const char *zipfile);
static void fileconversion_mv_tmp_to_rp(const char *tmp, const char *rp);
static void fileconversion_run(fHandle_t *d);
static bool fileconversion_up_to_date(struct timespec t,const char *vp,const int vp_l);
static long fileconversion_estimate_filesize(const char *vp,const int vp_l);
static bool fileconversion_remove_if_not_up_to_date(zpath_t *zpath);
static bool fileconversion_filldir(fuse_fill_dir_t filler,void *buf, const char *name, const struct stat *stbuf,ht_t *no_dups);
static bool _fileconversion_is_placeholder(const char *c);
static void fileconversion_free_argv(char const * const * cmd,const char * const * cmd_orig);
static void fileconversion_zpath_init(zpath_t *zpath,const virtualpath_t  *vipa);
static bool fileconversion_getattr(struct stat *stbuf,const zpath_t *zpath,const virtualpath_t *vipa);
static struct fileconversion_rule **config_fileconversion_rules(void);
static bool config_fileconversion_exclude(const char *vp, const int vp_l,const struct fileconversion_rule *ac);
static bool config_fileconversion_file_is_invalid(const char *path,const int path_l, const struct stat *st, const char *rootpath);
static long config_fileconversion_estimate_filesize(const struct fileconversion_files *ff, bool *rememberFileSize);
static int config_fileconversion_add_virtual_infiles(struct fileconversion_files *ff);
static enum enum_fileconversion_run_res config_fileconversion_run(struct fileconversion_files *ff);
static void struct_fileconversion_files_init(struct fileconversion_files *ff,const char *vp,const int vp_l);
static void struct_fileconversion_files_destroy_txtbuf(struct fileconversion_files *ff);
static void struct_fileconversion_files_destroy(struct fileconversion_files *ff);
static void fc_wait_concurrent(const struct fileconversion_rule *ac, const int inc);
static void fc_init(void);
static const char *fc_fileext(const char *vp, const int vp_l,const struct fileconversion_rule *ac);
static bool _fc_patterns_match(const char *vp, const int vp_l,const char ** const patterns[], int * const patterns_l[], int *count);
static bool _fc_matches(const char *vp, const int vp_l,const struct fileconversion_rule *ac);
static void fc_vgenerated_from_vinfile(char *generated,const char *vp,const int vp_l, const struct fileconversion_rule *ac);
static bool _fileconversion_rule_matches(struct fileconversion_files *ff);
static int _fileconversion_realinfiles(struct fileconversion_files *ff,const struct fileconversion_rule *ac);
static int fileconversion_realinfiles(struct fileconversion_files *ff);
static void fc_maybe_reset_atime_in_future(const fHandle_t *d);
static int _fc_fd_open(const char *path, int *fd);
static int fc_run(struct fileconversion_files *ff);
static int _fileconversion_filecontent_append(const int flags, struct fileconversion_files *ff, const char *s,const long s_l);
static bool check_configuration1();
static bool check_configuration(const char *mnt);
static ht_entry_t *ht_get_entry(ht_t *ht, const char* key,const ht_keylen_t key_l,ht_hash_t hash,const bool create);
static void *ht_set(ht_t *ht,const char* key,const ht_keylen_t key_l,ht_hash_t hash, const void* value);
static bool ht_only_once(ht_t *ht,const char *s,const int s_l_or_zero);
static int _xmp_getattr(const char *path, struct stat *stbuf);
static int xmp_access(const char *path, int mask);
static int xmp_open(const char *path, struct fuse_file_info *fi);
static int _xmp_readdir(const char *path, void *buf, fuse_fill_dir_t filler,off_t offset, struct fuse_file_info *fi);
static int xmp_release(const char *path, struct fuse_file_info *fi);
static ht_t *ht_set_id(const int id,ht_t *ht);
static const char* rootpath(const root_t *r);
static const char* report_rootpath(const root_t *r);
static int rootindex(const root_t *r);
static void root_init(const bool isWritable,root_t *r, const char *path, const char **annotations, const int annotations_n);
static char **split_paths_by_colon(char *v, int l[2], char **ss);
static yes_zero_no_t parse_key_numvalue(const char *line, const char *key, int *value);
static void root_read_properties(root_t *r,const char **annotations, const int annotations_n);
static void init_mutex(void);
static zpath_t *directory_init_zpath(directory_t *dir,const zpath_t *zpath);
static void directory_destroy(directory_t *d);
static void directory_ensure_capacity(directory_t *d, const int min, const int newCapacity);
static void directory_add(uint8_t flags,directory_t *dir, int64_t inode, const char *n0,uint64_t size, time_t mtime,zip_uint32_t crc);
static void stat_set_dir(struct stat *s);
static bool _stat_direct(const int opt_filldir_findrp, struct stat *st,const char *rp, const int rp_l,  root_t *r, const char *callerFunc);
static bool stat_from_cache_or_direct_or_async(const int opt_filldir_findrp,const char *rp, const int rp_l,struct stat *st,root_t *r);
static void mkSymlinkAfterStartPrepare();
static const char *key_from_rp(const bool internalize,const char *rp, const int rp_l, int *key_l, ht_hash_t *hash, root_t *r);
static const char *internalize_rp(const char *rp,const int rp_l, ht_hash_t hash, root_t *r);
static int zpath_strlen(const zpath_t *zpath,int s);
static MAYBE_INLINE fHandle_t* fhandle_at_index(int i);
static void  zpath_set_atime(const zpath_t *zpath);
static int zpath_newstr(zpath_t *zpath);
static bool zpath_strncat(zpath_t *zpath,const char *s,int len);
static int zpath_commit_hash(const zpath_t *zpath, ht_hash_t *hash);
static void zpath_set_realpath(zpath_t *zpath, const char *rp);
static void _zpath_assert_strlen(const char *fn,const char *file,const int line,zpath_t *zpath);
static void zpath_reset_keep_VP(zpath_t *zpath);
static void zpath_init(zpath_t *zpath, const virtualpath_t *vipa);
static bool zpath_stat(const int opt_filldir_findrp, zpath_t *zpath);
static off_t fsize_from_hashtable(ino_t inode);
static void fsize_to_hashtable(const char *vp, const int vp_l, const off_t size);
static int virtual_dirpath_to_zipfile(const char *vp, const int vp_l,int *cutr, char *append[]);
static bool readdir_from_cache_zip_or_filesystem(const int opt_filldir_findrp,directory_t *dir);
static bool readdir_from_zip(directory_t *dir);
static bool readir_from_filesystem(directory_t *dir);
static bool append_realpath_warnings_errors(zpath_t *zpath);
static bool test_realpath_pfx(const bool dirFileconversion,  int opt_filldir_findrp, zpath_t *zpath, root_t *r);
static bool test_realpath(const int opt_filldir_findrp,const int zpath_flags,zpath_t *zpath, root_t *r);
static bool zpath_expand_symlinks(zpath_t *zpath);
static bool find_realpath_for_root(const int opt_filldir_findrp,zpath_t *zpath,root_t *r);
static long search_file_which_roots(const char *vp,const int vp_l,const bool path_starts_with_fileconversion);
static bool find_realpath_roots_by_mask(const int opt_filldir_findrp,zpath_t *zpath,const long roots);
static bool find_realpath_any_root( int opt_filldir_findrp,zpath_t *zpath,const root_t *onlyThisRoot);
static bool _find_realpath_other_root(zpath_t *zpath);
static bool find_realpath_other_root(zpath_t *zpath);
static void fhandle_init(fHandle_t *d, const zpath_t *zpath);
static fHandle_t* _fhandle_create_locked(const int flags,const uint64_t fh, const zpath_t *zpath);
static uint64_t next_fh();
static fHandle_t* fhandle_create(const int flags, uint64_t *fh, const zpath_t *zpath);
static bool fhandle_currently_reading_writing(const fHandle_t *d);
static void fhandle_destroy(fHandle_t *d);
static void fhandle_destroy_now(fHandle_t *d);
static void fhandle_destroy_those_that_are_marked(void);
static fHandle_t* fhandle_get(const virtualpath_t *vipa,const uint64_t fh);
static bool fhandle_find_identical(const fHandle_t *d);
static ino_t next_inode(void);
static ino_t make_inode(const ino_t inode0,root_t *r, const int entryIdx,const char *rp);
static ino_t inode_from_virtualpath(const char *vp,const int vp_l);
static int zipentry_placeholder_expand(char *u,const char *orig, const char *rp, const directory_t *dir);
static void filler_add(const int opt_filldir_findrp,fuse_fill_dir_t filler,void *buf, const char *name, int name_l,const struct stat *st, ht_t *no_dups);
static int filler_readdir_zip(const int opt_filldir_findrp,zpath_t *zpath,void *buf, fuse_fill_dir_t filler,ht_t *no_dups);
static bool filler_readdir(const int opt_filldir_findrp,zpath_t *zpath, void *buf, fuse_fill_dir_t filler,ht_t *no_dups);
static int xmp_statfs(const char *path, struct statvfs *st);
static int mk_parentdir_if_sufficient_storage_space(const char *rp);
static int realpath_mk_parent(char *rp, const virtualpath_t *vip);
static void setSpecialFile(const int opt, const enum enum_special_files id,virtualpath_t *vipa);
static void init_special_files();
static int virtualpath_init(virtualpath_t *vipa, const char *vpath, char *buf);
static int virtualpath_error(const virtualpath_t *vipa,const int create_or_del);
static int _xmp_getattr(const char *vpath, struct stat *st);
static int xmp_readlink(const char *vpath, char *buf, size_t size);
static int xmp_unlink(const char *vpath);
static int xmp_rmdir(const char *vpath);
static int open_for_reading(const virtualpath_t *vipa, struct fuse_file_info *fi);
static int xmp_open(const char *vpath, struct fuse_file_info *fi);
static int _xmp_readdir(const char *vpath, void *buf, fuse_fill_dir_t filler,off_t offset, struct fuse_file_info *fi);
static int xmp_mkdir(const char *vpath, mode_t mode);
static int create_or_open(const virtualpath_t *vipa, mode_t mode, struct fuse_file_info *fi);
static int xmp_write(const char *vpath, const char *buf, size_t size,off_t offset, struct fuse_file_info *fi);
static int my_zip_fclose(zip_file_t *z,const char *path);
static int my_zip_close(zip_t *z,const char *path);
static zip_t *my_zip_open(const char *orig);
static zip_file_t *my_zip_fopen(zip_t *za, const char *entry, const zip_flags_t flags, const char *path);
static off_t _my_zip_fread(zip_file_t *file, void *buf, const zip_uint64_t nbytes, const char *func);
static off_t fhandle_zip_fread(fHandle_t *d, void *buf,  zip_uint64_t nbytes, const char *errmsg);
static bool fhandle_zip_fseek(fHandle_t *d, const off_t offset, const char *errmsg);
static zip_file_t *fhandle_zip_open(fHandle_t *d,const char *msg);
static void fhandle_zip_fclose(fHandle_t *d);
static off_t fhandle_read_zip(char *buf, const off_t size, const off_t offset,fHandle_t *d);
static void fhandle_prepare_in_RW(fHandle_t *d,const int open_flags);
static int xmp_read(const char *vpath, char *buf, const size_t size, const off_t offset,struct fuse_file_info *fi);
static int _xmp_read(const virtualpath_t *vipa, fHandle_t *d, char *buf, const size_t size, const off_t offset,int fd);
static int xmp_release(const char *vpath, struct fuse_file_info *fi);
static int xmp_flush(const char *vpath, struct fuse_file_info *fi);
static void _exit_ZIPsFS(const char *func, const int line_num);
